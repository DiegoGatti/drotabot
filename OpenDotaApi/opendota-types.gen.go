// Package opendotaapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.2 DO NOT EDIT.
package opendotaapi

import (
	"time"
)

// BenchmarksResponse defines model for BenchmarksResponse.
type BenchmarksResponse struct {
	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Result result
	Result *struct {
		GoldPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"gold_per_min,omitempty"`
		HeroDamagePerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"hero_damage_per_min,omitempty"`
		HeroHealingPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"hero_healing_per_min,omitempty"`
		KillsPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"kills_per_min,omitempty"`
		LastHitsPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"last_hits_per_min,omitempty"`
		TowerDamage *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *int `json:"value,omitempty"`
		} `json:"tower_damage,omitempty"`
		XpPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"xp_per_min,omitempty"`
	} `json:"result,omitempty"`
}

// DistributionsResponse defines model for DistributionsResponse.
type DistributionsResponse struct {
	// CountryMmr country_mmr
	CountryMmr *struct {
		// Commmand command
		Commmand *string `json:"commmand,omitempty"`

		// Fields fields
		Fields *[]struct {
			// ColumnID columnID
			ColumnID *int `json:"columnID,omitempty"`

			// DataTypeID dataTypeID
			DataTypeID *int `json:"dataTypeID,omitempty"`

			// DataTypeModifier dataTypeModifier
			DataTypeModifier *int `json:"dataTypeModifier,omitempty"`

			// DataTypeSize dataTypeSize
			DataTypeSize *int `json:"dataTypeSize,omitempty"`

			// Format format
			Format *string `json:"format,omitempty"`

			// Name Field name
			Name *string `json:"name,omitempty"`

			// TableID tableID
			TableID *int `json:"tableID,omitempty"`
		} `json:"fields,omitempty"`

		// RowAsArray rowAsArray
		RowAsArray *bool `json:"rowAsArray,omitempty"`

		// RowCount rowCount
		RowCount *int `json:"rowCount,omitempty"`

		// Rows rows
		Rows *[]struct {
			// Avg avg
			Avg *string `json:"avg,omitempty"`

			// Common common
			Common *string `json:"common,omitempty"`

			// Count count
			Count *int `json:"count,omitempty"`

			// Loccountrycode loccountrycode
			Loccountrycode *string `json:"loccountrycode"`
		} `json:"rows,omitempty"`
	} `json:"country_mmr,omitempty"`

	// Mmr mmr
	Mmr *struct {
		// Commmand command
		Commmand *string `json:"commmand,omitempty"`

		// Fields fields
		Fields *[]struct {
			// ColumnID columnID
			ColumnID *int `json:"columnID,omitempty"`

			// DataTypeID dataTypeID
			DataTypeID *int `json:"dataTypeID,omitempty"`

			// DataTypeModifier dataTypeModifier
			DataTypeModifier *int `json:"dataTypeModifier,omitempty"`

			// DataTypeSize dataTypeSize
			DataTypeSize *int `json:"dataTypeSize,omitempty"`

			// Format format
			Format *string `json:"format,omitempty"`

			// Name Field name
			Name *string `json:"name,omitempty"`

			// TableID tableID
			TableID *int `json:"tableID,omitempty"`
		} `json:"fields,omitempty"`

		// RowAsArray rowAsArray
		RowAsArray *bool `json:"rowAsArray,omitempty"`

		// RowCount rowCount
		RowCount *int `json:"rowCount,omitempty"`

		// Rows rows
		Rows *[]struct {
			// Bin bin
			Bin *int `json:"bin,omitempty"`

			// BinName bin_name
			BinName *int `json:"bin_name,omitempty"`

			// Count count
			Count *int `json:"count,omitempty"`

			// CumulativeSum cumulative_sum
			CumulativeSum *int `json:"cumulative_sum,omitempty"`
		} `json:"rows,omitempty"`

		// Sum sum
		Sum *struct {
			// Count count
			Count *int `json:"count,omitempty"`
		} `json:"sum,omitempty"`
	} `json:"mmr,omitempty"`

	// Ranks ranks
	Ranks *struct {
		// Commmand command
		Commmand *string `json:"commmand,omitempty"`

		// Fields fields
		Fields *[]struct {
			// ColumnID columnID
			ColumnID *int `json:"columnID,omitempty"`

			// DataTypeID dataTypeID
			DataTypeID *int `json:"dataTypeID,omitempty"`

			// DataTypeModifier dataTypeModifier
			DataTypeModifier *int `json:"dataTypeModifier,omitempty"`

			// DataTypeSize dataTypeSize
			DataTypeSize *int `json:"dataTypeSize,omitempty"`

			// Format format
			Format *string `json:"format,omitempty"`

			// Name Field name
			Name *string `json:"name,omitempty"`

			// TableID tableID
			TableID *int `json:"tableID,omitempty"`
		} `json:"fields,omitempty"`

		// RowAsArray rowAsArray
		RowAsArray *bool `json:"rowAsArray,omitempty"`

		// RowCount rowCount
		RowCount *int `json:"rowCount,omitempty"`

		// Rows rows
		Rows *[]struct {
			// Bin bin
			Bin *int `json:"bin,omitempty"`

			// BinName bin_name
			BinName *int `json:"bin_name,omitempty"`

			// Count count
			Count *int `json:"count,omitempty"`

			// CumulativeSum cumulative_sum
			CumulativeSum *int `json:"cumulative_sum,omitempty"`
		} `json:"rows,omitempty"`

		// Sum sum
		Sum *struct {
			// Count count
			Count *int `json:"count,omitempty"`
		} `json:"sum,omitempty"`
	} `json:"ranks,omitempty"`
}

// HeroDurationsResponse defines model for HeroDurationsResponse.
type HeroDurationsResponse struct {
	// DurationBin Lower bound of number of seconds the match lasted
	DurationBin *string `json:"duration_bin,omitempty"`

	// GamesPlayed Number of games played
	GamesPlayed *int `json:"games_played,omitempty"`

	// Wins Number of wins
	Wins *int `json:"wins,omitempty"`
}

// HeroItemPopularityResponse defines model for HeroItemPopularityResponse.
type HeroItemPopularityResponse struct {
	// EarlyGameItems Items bought in the first 10 min of the game, with cost at least 700
	EarlyGameItems *struct {
		// Item Number of item bought
		Item *int `json:"item,omitempty"`
	} `json:"early_game_items,omitempty"`

	// LateGameItems Items bought at least 25 min after game started, with cost at least 4000
	LateGameItems *struct {
		// Item Number of item bought
		Item *int `json:"item,omitempty"`
	} `json:"late_game_items,omitempty"`

	// MidGameItems Items bought between 10 and 25 min of the game, with cost at least 2000
	MidGameItems *struct {
		// Item Number of item bought
		Item *int `json:"item,omitempty"`
	} `json:"mid_game_items,omitempty"`

	// StartGameItems Items bought before game started
	StartGameItems *struct {
		// Item Number of item bought
		Item *int `json:"item,omitempty"`
	} `json:"start_game_items,omitempty"`
}

// HeroMatchupsResponse defines model for HeroMatchupsResponse.
type HeroMatchupsResponse struct {
	// GamesPlayed Number of games played
	GamesPlayed *int `json:"games_played,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Wins Number of games won
	Wins *int `json:"wins,omitempty"`
}

// HeroObjectResponse defines model for HeroObjectResponse.
type HeroObjectResponse struct {
	// AttackType Hero attack type, either 'Melee' or 'Ranged'
	AttackType *string `json:"attack_type,omitempty"`

	// Id The ID value of the hero played
	Id int `json:"id"`

	// LocalizedName Hero name
	LocalizedName *string `json:"localized_name,omitempty"`

	// Name Dota hero command name
	Name *string `json:"name,omitempty"`

	// PrimaryAttr Hero primary shorthand attribute name, e.g. 'agi'
	PrimaryAttr *string   `json:"primary_attr,omitempty"`
	Roles       *[]string `json:"roles,omitempty"`
}

// HeroStatsResponse defines model for HeroStatsResponse.
type HeroStatsResponse struct {
	// N1Pick Herald picks
	N1Pick *int `json:"1_pick,omitempty"`

	// N1Win Herald wins
	N1Win *int `json:"1_win,omitempty"`

	// N2Pick Guardian picks
	N2Pick *int `json:"2_pick,omitempty"`

	// N2Win Guardian wins
	N2Win *int `json:"2_win,omitempty"`

	// N3Pick Crusader picks
	N3Pick *int `json:"3_pick,omitempty"`

	// N3Win Crusader wins
	N3Win *int `json:"3_win,omitempty"`

	// N4Pick Archon picks
	N4Pick *int `json:"4_pick,omitempty"`

	// N4Win Archon wins
	N4Win *int `json:"4_win,omitempty"`

	// N5Pick Legend picks
	N5Pick *int `json:"5_pick,omitempty"`

	// N5Win Legend wins
	N5Win *int `json:"5_win,omitempty"`

	// N6Pick Ancient picks
	N6Pick *int `json:"6_pick,omitempty"`

	// N6Win Ancient wins
	N6Win *int `json:"6_win,omitempty"`

	// N7Pick Divine picks
	N7Pick *int `json:"7_pick,omitempty"`

	// N7Win Divine wins
	N7Win *int `json:"7_win,omitempty"`

	// N8Pick Immortal picks
	N8Pick *int `json:"8_pick,omitempty"`

	// N8Win Immortal wins
	N8Win *int `json:"8_win,omitempty"`

	// AgiGain agi_gain
	AgiGain *float32 `json:"agi_gain,omitempty"`

	// AttackPoint attack_point
	AttackPoint *float32 `json:"attack_point,omitempty"`

	// AttackRange attack_range
	AttackRange *int `json:"attack_range,omitempty"`

	// AttackRate attack_rate
	AttackRate *float32 `json:"attack_rate,omitempty"`

	// AttackType attack_type
	AttackType *string `json:"attack_type,omitempty"`

	// BaseAgi base_agi
	BaseAgi *int `json:"base_agi,omitempty"`

	// BaseArmor base_armor
	BaseArmor *int `json:"base_armor,omitempty"`

	// BaseAttackMax base_attack_max
	BaseAttackMax *int `json:"base_attack_max,omitempty"`

	// BaseAttackMin base_attack_min
	BaseAttackMin *int `json:"base_attack_min,omitempty"`

	// BaseAttackTime base_attack_time
	BaseAttackTime *int `json:"base_attack_time,omitempty"`

	// BaseHealth base_health
	BaseHealth *int `json:"base_health,omitempty"`

	// BaseHealthRegen base_health_regen
	BaseHealthRegen *float32 `json:"base_health_regen,omitempty"`

	// BaseInt base_int
	BaseInt *int `json:"base_int,omitempty"`

	// BaseMana base_mana
	BaseMana *int `json:"base_mana,omitempty"`

	// BaseManaRegen base_mana_regen
	BaseManaRegen *int `json:"base_mana_regen,omitempty"`

	// BaseMr base_mr
	BaseMr *int `json:"base_mr,omitempty"`

	// BaseStr base_str
	BaseStr *int `json:"base_str,omitempty"`

	// CmEnabled cm_enabled
	CmEnabled *bool `json:"cm_enabled,omitempty"`

	// DayVision day_vision
	DayVision *int `json:"day_vision,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Icon icon
	Icon *string `json:"icon,omitempty"`

	// Id The ID value of the hero played
	Id *int `json:"id,omitempty"`

	// Img img
	Img *string `json:"img,omitempty"`

	// IntGain int_gain
	IntGain *float32 `json:"int_gain,omitempty"`

	// Legs legs
	Legs *int `json:"legs,omitempty"`

	// LocalizedName Hero name
	LocalizedName *string `json:"localized_name,omitempty"`

	// MoveSpeed move_speed
	MoveSpeed *int `json:"move_speed,omitempty"`

	// Name Dota hero command name
	Name *string `json:"name,omitempty"`

	// NightVision night_vision
	NightVision *int `json:"night_vision,omitempty"`

	// NullPick null_pick
	NullPick *int `json:"null_pick,omitempty"`

	// NullWin null_win
	NullWin *int `json:"null_win,omitempty"`

	// PrimaryAttr primary_attr
	PrimaryAttr *string `json:"primary_attr,omitempty"`

	// ProBan pro_ban
	ProBan *int `json:"pro_ban,omitempty"`

	// ProPick pro_pick
	ProPick *int `json:"pro_pick,omitempty"`

	// ProWin pro_win
	ProWin *int `json:"pro_win,omitempty"`

	// ProjectileSpeed projectile_speed
	ProjectileSpeed *int `json:"projectile_speed,omitempty"`

	// Roles roles
	Roles *[]string `json:"roles,omitempty"`

	// StrGain str_gain
	StrGain *float32 `json:"str_gain,omitempty"`

	// TurboPicks Picks in Turbo mode this month
	TurboPicks *int `json:"turbo_picks,omitempty"`

	// TurboWins Wins in Turbo mode this month
	TurboWins *int `json:"turbo_wins,omitempty"`

	// TurnRate turn_rate
	TurnRate *float32 `json:"turn_rate,omitempty"`
}

// LeagueObjectResponse defines model for LeagueObjectResponse.
type LeagueObjectResponse struct {
	// Banner banner
	Banner *string `json:"banner,omitempty"`

	// Leagueid leagueid
	Leagueid *int `json:"leagueid,omitempty"`

	// Name League name
	Name *string `json:"name,omitempty"`

	// Ticket ticket
	Ticket *string `json:"ticket,omitempty"`

	// Tier tier
	Tier *string `json:"tier,omitempty"`
}

// MatchObjectResponse defines model for MatchObjectResponse.
type MatchObjectResponse struct {
	// DireName The Dire's team name
	DireName *string `json:"dire_name,omitempty"`

	// DireScore Number of kills the Dire team had when the match ended
	DireScore *int `json:"dire_score,omitempty"`

	// DireTeamId The Dire's team_id
	DireTeamId *int `json:"dire_team_id,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// LeagueName Name of league the match took place in
	LeagueName *string `json:"league_name,omitempty"`

	// Leagueid Identifier for the league the match took place in
	Leagueid *int `json:"leagueid,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// Radiant Whether the team/player/hero was on Radiant
	Radiant *bool `json:"radiant,omitempty"`

	// RadiantName The Radiant's team name
	RadiantName *string `json:"radiant_name,omitempty"`

	// RadiantScore Number of kills the Radiant team had when the match ended
	RadiantScore *int `json:"radiant_score,omitempty"`

	// RadiantTeamId The Radiant's team_id
	RadiantTeamId *int `json:"radiant_team_id,omitempty"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// SeriesId Identifier for the series of the match
	SeriesId *int `json:"series_id,omitempty"`

	// SeriesType Type of series the match was
	SeriesType *int `json:"series_type,omitempty"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`
}

// MatchResponse defines model for MatchResponse.
type MatchResponse struct {
	// AllWordCounts Word counts of the all chat messages in the player's games
	AllWordCounts *map[string]interface{} `json:"all_word_counts,omitempty"`

	// BarracksStatusDire Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game.
	BarracksStatusDire *int `json:"barracks_status_dire,omitempty"`

	// BarracksStatusRadiant Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game.
	BarracksStatusRadiant *int `json:"barracks_status_radiant,omitempty"`

	// Chat Array containing information on the chat of the game
	Chat *[]struct {
		// Key The message the player sent
		Key *string `json:"key,omitempty"`

		// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
		PlayerSlot *int `json:"player_slot"`

		// Slot slot
		Slot *int `json:"slot,omitempty"`

		// Time Time in seconds at which the message was said
		Time *int `json:"time,omitempty"`

		// Unit Name of the player who sent the message
		Unit *string `json:"unit,omitempty"`
	} `json:"chat,omitempty"`

	// Cluster cluster
	Cluster *int `json:"cluster,omitempty"`

	// Comeback Maximum gold disadvantage of the player's team if they won the match
	Comeback *int `json:"comeback,omitempty"`

	// Cosmetics cosmetics
	Cosmetics *map[string]int `json:"cosmetics,omitempty"`

	// DireScore Number of kills the Dire team had when the match ended
	DireScore *int `json:"dire_score,omitempty"`

	// DireTeam dire_team
	DireTeam *map[string]interface{} `json:"dire_team,omitempty"`

	// DraftTimings draft_timings
	DraftTimings *[]struct {
		// ActiveTeam active_team
		ActiveTeam *int `json:"active_team,omitempty"`

		// ExtraTime extra_time
		ExtraTime *int `json:"extra_time,omitempty"`

		// HeroId The ID value of the hero played
		HeroId *int `json:"hero_id,omitempty"`

		// Order order
		Order *int `json:"order,omitempty"`

		// Pick pick
		Pick *bool `json:"pick,omitempty"`

		// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
		PlayerSlot *int `json:"player_slot"`

		// TotalTimeTaken total_time_taken
		TotalTimeTaken *int `json:"total_time_taken,omitempty"`
	} `json:"draft_timings,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// Engine engine
	Engine *int `json:"engine,omitempty"`

	// FirstBloodTime Time in seconds at which first blood occurred
	FirstBloodTime *int `json:"first_blood_time,omitempty"`

	// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode *int `json:"game_mode,omitempty"`

	// HumanPlayers Number of human players in the game
	HumanPlayers *int `json:"human_players,omitempty"`

	// League league
	League *map[string]interface{} `json:"league,omitempty"`

	// Leagueid leagueid
	Leagueid *int `json:"leagueid,omitempty"`

	// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType *int `json:"lobby_type,omitempty"`

	// Loss Maximum gold disadvantage of the player's team if they lost the match
	Loss *int `json:"loss,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// MatchSeqNum match_seq_num
	MatchSeqNum *int `json:"match_seq_num,omitempty"`

	// MyWordCounts Word counts of the player's all chat messages
	MyWordCounts *map[string]interface{} `json:"my_word_counts,omitempty"`

	// NegativeVotes Number of negative votes the replay received in the in-game client
	NegativeVotes *int `json:"negative_votes,omitempty"`

	// Objectives objectives
	Objectives *[]map[string]interface{} `json:"objectives,omitempty"`

	// Patch Information on the patch version the game is played on
	Patch *int `json:"patch,omitempty"`

	// PicksBans Array containing information on the draft. Each item contains a boolean relating to whether the choice is a pick or a ban, the hero ID, the team the picked or banned it, and the order.
	PicksBans *[]struct {
		// HeroId The ID value of the hero played
		HeroId *int `json:"hero_id,omitempty"`

		// IsPick Boolean indicating whether the choice is a pick or a ban
		IsPick *bool `json:"is_pick,omitempty"`

		// Order The order of the pick or ban
		Order *int `json:"order,omitempty"`

		// Team The team that picked or banned the hero
		Team *int `json:"team,omitempty"`
	} `json:"picks_bans,omitempty"`

	// Players Array of information on individual players
	Players *[]struct {
		// Abandons abandons
		Abandons *int `json:"abandons,omitempty"`

		// AbilityTargets Object containing information on who the player used their abilities on
		AbilityTargets *map[string]interface{} `json:"ability_targets,omitempty"`

		// AbilityUpgradesArr An array describing how abilities were upgraded
		AbilityUpgradesArr *[]int `json:"ability_upgrades_arr,omitempty"`

		// AbilityUses Object containing information on how many times the played used their abilities
		AbilityUses *map[string]interface{} `json:"ability_uses,omitempty"`

		// AccountId The player account ID
		AccountId *int `json:"account_id,omitempty"`

		// Actions Object containing information on how many and what type of actions the player issued to their hero
		Actions *map[string]interface{} `json:"actions,omitempty"`

		// ActionsPerMin Actions per minute
		ActionsPerMin *int `json:"actions_per_min,omitempty"`

		// AdditionalUnits Object containing information on additional units the player had under their control
		AdditionalUnits *[]map[string]interface{} `json:"additional_units"`

		// AncientKills Total number of Ancient creeps killed by the player
		AncientKills *int `json:"ancient_kills,omitempty"`

		// Assists Number of assists the player had
		Assists *int `json:"assists,omitempty"`

		// Backpack0 Item in backpack slot 0
		Backpack0 *int `json:"backpack_0,omitempty"`

		// Backpack1 Item in backpack slot 1
		Backpack1 *int `json:"backpack_1,omitempty"`

		// Backpack2 Item in backpack slot 2
		Backpack2 *int `json:"backpack_2,omitempty"`

		// Benchmarks Object containing information on certain benchmarks like GPM, XPM, KDA, tower damage, etc
		Benchmarks *map[string]interface{} `json:"benchmarks,omitempty"`

		// BuybackCount Total number of buyback the player used
		BuybackCount *int `json:"buyback_count,omitempty"`

		// BuybackLog Array containing information about buybacks
		BuybackLog *[]struct {
			// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
			PlayerSlot *int `json:"player_slot"`

			// Slot slot
			Slot *int `json:"slot,omitempty"`

			// Time Time in seconds the buyback occurred
			Time *int `json:"time,omitempty"`
		} `json:"buyback_log,omitempty"`

		// CampsStacked Number of camps stacked
		CampsStacked *int `json:"camps_stacked,omitempty"`

		// Cluster cluster
		Cluster *int `json:"cluster,omitempty"`

		// ConnectionLog Array containing information about the player's disconnections and reconnections
		ConnectionLog *[]struct {
			// Event Event that occurred
			Event *string `json:"event,omitempty"`

			// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
			PlayerSlot *int `json:"player_slot"`

			// Time Game time in seconds the event ocurred
			Time *int `json:"time,omitempty"`
		} `json:"connection_log,omitempty"`

		// Cosmetics cosmetics
		Cosmetics *[]struct {
			CreationDate    *time.Time `json:"creation_date"`
			ImageInventory  *string    `json:"image_inventory"`
			ImagePath       *string    `json:"image_path"`
			ItemDescription *string    `json:"item_description"`
			ItemId          *int       `json:"item_id,omitempty"`
			ItemName        *string    `json:"item_name,omitempty"`
			ItemRarity      *string    `json:"item_rarity"`
			ItemTypeName    *string    `json:"item_type_name"`

			// Name name
			Name         *string `json:"name"`
			Prefab       *string `json:"prefab,omitempty"`
			UsedByHeroes *string `json:"used_by_heroes"`
		} `json:"cosmetics,omitempty"`

		// CourierKills Total number of courier kills the player had
		CourierKills *int `json:"courier_kills,omitempty"`

		// CreepsStacked Number of creeps stacked
		CreepsStacked *int `json:"creeps_stacked,omitempty"`

		// Damage Object containing information about damage dealt by the player to different units
		Damage *map[string]interface{} `json:"damage,omitempty"`

		// DamageInflictor Object containing information about about the sources of this player's damage to heroes
		DamageInflictor *map[string]interface{} `json:"damage_inflictor,omitempty"`

		// DamageInflictorReceived Object containing information about the sources of damage received by this player from heroes
		DamageInflictorReceived *map[string]interface{} `json:"damage_inflictor_received,omitempty"`

		// DamageTaken Object containing information about from whom the player took damage
		DamageTaken *map[string]interface{} `json:"damage_taken,omitempty"`

		// DamageTargets Object containing information on how and how much damage the player dealt to other heroes
		DamageTargets *map[string]interface{} `json:"damage_targets,omitempty"`

		// Deaths Number of deaths
		Deaths *int `json:"deaths,omitempty"`

		// Denies Number of denies
		Denies *int `json:"denies,omitempty"`

		// DnT Array containing number of denies at different times of the match
		DnT *[]int `json:"dn_t,omitempty"`

		// Duration Duration of the game in seconds
		Duration *int `json:"duration,omitempty"`

		// FirstPurchaseTime Object with information on when the player first puchased an item
		FirstPurchaseTime *map[string]interface{} `json:"first_purchase_time,omitempty"`

		// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
		GameMode *int `json:"game_mode,omitempty"`

		// Gold Gold at the end of the game
		Gold *int `json:"gold,omitempty"`

		// GoldPerMin Gold Per Minute obtained by this player
		GoldPerMin *int `json:"gold_per_min,omitempty"`

		// GoldReasons Object containing information on how the player gainined gold over the course of the match
		GoldReasons *map[string]interface{} `json:"gold_reasons,omitempty"`

		// GoldSpent How much gold the player spent
		GoldSpent *int `json:"gold_spent,omitempty"`

		// GoldT Array containing total gold at different times of the match
		GoldT *[]int `json:"gold_t,omitempty"`

		// HeroDamage Hero Damage Dealt
		HeroDamage *int `json:"hero_damage,omitempty"`

		// HeroHealing Hero Healing Done
		HeroHealing *int `json:"hero_healing,omitempty"`

		// HeroHits Object containing information on how many ticks of damages the hero inflicted with different spells and damage inflictors
		HeroHits *map[string]interface{} `json:"hero_hits,omitempty"`

		// HeroId The ID value of the hero played
		HeroId *int `json:"hero_id,omitempty"`

		// HeroKills Total number of heroes killed by the player
		HeroKills *int `json:"hero_kills,omitempty"`

		// IsRadiant Boolean for whether or not the player is on Radiant
		IsRadiant *bool `json:"isRadiant,omitempty"`

		// IsRoaming Boolean referring to whether or not the player roamed
		IsRoaming *bool `json:"is_roaming"`

		// Item0 Item in the player's first slot
		Item0 *int `json:"item_0,omitempty"`

		// Item1 Item in the player's second slot
		Item1 *int `json:"item_1,omitempty"`

		// Item2 Item in the player's third slot
		Item2 *int `json:"item_2,omitempty"`

		// Item3 Item in the player's fourth slot
		Item3 *int `json:"item_3,omitempty"`

		// Item4 Item in the player's fifth slot
		Item4 *int `json:"item_4,omitempty"`

		// Item5 Item in the player's sixth slot
		Item5 *int `json:"item_5,omitempty"`

		// ItemUsage Object containing binary integers the tell whether the item was purchased by the player (note: this is always 1)
		ItemUsage *map[string]interface{} `json:"item_usage,omitempty"`

		// ItemUses Object containing information about how many times a player used items
		ItemUses *map[string]interface{} `json:"item_uses,omitempty"`

		// ItemWin Object with information on whether or not the item won
		ItemWin *map[string]interface{} `json:"item_win,omitempty"`

		// Kda kda
		Kda *float32 `json:"kda,omitempty"`

		// KillStreaks Object containing information about the player's killstreaks
		KillStreaks *map[string]interface{} `json:"kill_streaks,omitempty"`

		// Killed Object containing information about what units the player killed
		Killed *map[string]interface{} `json:"killed,omitempty"`

		// KilledBy Object containing information about who killed the player
		KilledBy *map[string]interface{} `json:"killed_by,omitempty"`

		// Kills Number of kills
		Kills *int `json:"kills,omitempty"`

		// KillsLog Array containing information on which hero the player killed at what time
		KillsLog *[]struct {
			// Key Hero killed
			Key *string `json:"key,omitempty"`

			// Time Time in seconds the player killed the hero
			Time *int `json:"time,omitempty"`
		} `json:"kills_log,omitempty"`

		// KillsPerMin Number of kills per minute
		KillsPerMin *float32 `json:"kills_per_min,omitempty"`

		// Lane Integer referring to which lane the hero laned in
		Lane *int `json:"lane"`

		// LaneEfficiency lane_efficiency
		LaneEfficiency *float32 `json:"lane_efficiency,omitempty"`

		// LaneEfficiencyPct lane_efficiency_pct
		LaneEfficiencyPct *float32 `json:"lane_efficiency_pct,omitempty"`

		// LaneKills Total number of lane creeps killed by the player
		LaneKills *int `json:"lane_kills,omitempty"`

		// LanePos Object containing information on lane position
		LanePos *map[string]interface{} `json:"lane_pos,omitempty"`

		// LaneRole lane_role
		LaneRole *int `json:"lane_role"`

		// LastHits Number of last hits
		LastHits *int `json:"last_hits,omitempty"`

		// LastLogin Time of player's last login
		LastLogin *time.Time `json:"last_login"`

		// LeaverStatus Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
		LeaverStatus *int `json:"leaver_status,omitempty"`

		// Level Level at the end of the game
		Level *int `json:"level,omitempty"`

		// LhT Array describing last hits at each minute in the game
		LhT *[]int `json:"lh_t,omitempty"`

		// LifeState life_state
		LifeState *map[string]interface{} `json:"life_state,omitempty"`

		// LifeStateDead life_state_dead
		LifeStateDead *int `json:"life_state_dead,omitempty"`

		// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
		LobbyType *int `json:"lobby_type,omitempty"`

		// Lose Binary integer representing whether or not the player lost
		Lose *int `json:"lose,omitempty"`

		// MatchId The ID number of the match assigned by Valve
		MatchId *int `json:"match_id,omitempty"`

		// MaxHeroHit Object with information on the highest damage instance the player inflicted
		MaxHeroHit *map[string]interface{} `json:"max_hero_hit,omitempty"`

		// MultiKills Object with information on the number of the number of multikills the player had
		MultiKills *map[string]interface{} `json:"multi_kills,omitempty"`

		// Name name
		Name *string `json:"name"`

		// NecronomiconKills Total number of Necronomicon creeps killed by the player
		NecronomiconKills *int `json:"necronomicon_kills,omitempty"`

		// NeutralKills Total number of neutral creeps killed
		NeutralKills *int `json:"neutral_kills,omitempty"`

		// Obs Object with information on where the player placed observer wards. The location takes the form (outer number, inner number) and are from ~64-192.
		Obs *map[string]interface{} `json:"obs,omitempty"`

		// ObsLeftLog obs_left_log
		ObsLeftLog *[]map[string]interface{} `json:"obs_left_log,omitempty"`

		// ObsLog Object containing information on when and where the player placed observer wards
		ObsLog *[]map[string]interface{} `json:"obs_log,omitempty"`

		// ObsPlaced Total number of observer wards placed
		ObsPlaced *int `json:"obs_placed,omitempty"`

		// ObserverKills Total number of observer wards killed by the player
		ObserverKills *int `json:"observer_kills,omitempty"`

		// ObserverUses Number of observer wards used
		ObserverUses *int `json:"observer_uses,omitempty"`

		// PartyId party_id
		PartyId *int `json:"party_id,omitempty"`

		// Patch Integer representing the patch the game was played on
		Patch *int `json:"patch,omitempty"`

		// PermanentBuffs Array describing permanent buffs the player had at the end of the game. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/permanent_buffs.json
		PermanentBuffs *[]map[string]interface{} `json:"permanent_buffs,omitempty"`

		// Personaname Player's Steam name
		Personaname *string `json:"personaname"`

		// Pings Total number of pings
		Pings *int `json:"pings,omitempty"`

		// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
		PlayerSlot *int `json:"player_slot"`

		// Purchase Object containing information on the items the player purchased
		Purchase *map[string]interface{} `json:"purchase,omitempty"`

		// PurchaseLog Object containing information on when items were purchased
		PurchaseLog *[]struct {
			// Charges Integer amount of charges
			Charges *int `json:"charges,omitempty"`

			// Key String item ID
			Key *string `json:"key,omitempty"`

			// Time Time in seconds the item was bought
			Time *int `json:"time,omitempty"`
		} `json:"purchase_log,omitempty"`

		// PurchaseTime Object with information on when the player last purchased an item
		PurchaseTime *map[string]interface{} `json:"purchase_time,omitempty"`

		// PurchaseTpscroll Total number of TP scrolls purchased by the player
		PurchaseTpscroll *int `json:"purchase_tpscroll,omitempty"`

		// RadiantWin Boolean indicating whether Radiant won the match
		RadiantWin *bool `json:"radiant_win"`

		// RankTier The rank tier of the player. Tens place indicates rank, ones place indicates stars.
		RankTier *int `json:"rank_tier,omitempty"`

		// Region Integer corresponding to the region the game was played on
		Region *int `json:"region,omitempty"`

		// RoshanKills Total number of roshan kills (last hit on roshan) the player had
		RoshanKills *int `json:"roshan_kills,omitempty"`

		// RunePickups Number of runes picked up
		RunePickups *int `json:"rune_pickups,omitempty"`

		// Runes Object with information about which runes the player picked up
		Runes *map[string]int `json:"runes,omitempty"`

		// RunesLog Array with information on when runes were picked up
		RunesLog *[]struct {
			// Key key
			Key *int `json:"key,omitempty"`

			// Time Time in seconds rune picked up
			Time *int `json:"time,omitempty"`
		} `json:"runes_log,omitempty"`

		// Sen Object with information on where sentries were placed. The location takes the form (outer number, inner number) and are from ~64-192.
		Sen *map[string]interface{} `json:"sen,omitempty"`

		// SenLeftLog Array containing information on when and where the player placed sentries
		SenLeftLog *[]map[string]interface{} `json:"sen_left_log,omitempty"`

		// SenLog Array with information on when and where sentries were placed by the player
		SenLog *[]map[string]interface{} `json:"sen_log,omitempty"`

		// SenPlaced How many sentries were placed by the player
		SenPlaced *int `json:"sen_placed,omitempty"`

		// SentryKills Total number of sentry wards killed by the player
		SentryKills *int `json:"sentry_kills,omitempty"`

		// SentryUses Number of sentry wards used
		SentryUses *int `json:"sentry_uses,omitempty"`

		// StartTime The Unix timestamp at which the game started
		StartTime *int `json:"start_time,omitempty"`

		// Stuns Total stun duration of all stuns by the player
		Stuns *float32 `json:"stuns,omitempty"`

		// Times Time in seconds corresponding to the time of entries of other arrays in the match.
		Times *[]int `json:"times,omitempty"`

		// TotalGold Total gold at the end of the game
		TotalGold *int `json:"total_gold,omitempty"`

		// TotalXp Total experience at the end of the game
		TotalXp *int `json:"total_xp,omitempty"`

		// TowerDamage Total tower damage done by the player
		TowerDamage *int `json:"tower_damage,omitempty"`

		// TowerKills Total number of tower kills the player had
		TowerKills *int `json:"tower_kills,omitempty"`

		// Win Binary integer representing whether or not the player won
		Win *int `json:"win,omitempty"`

		// XpPerMin Experience Per Minute obtained by the player
		XpPerMin *int `json:"xp_per_min,omitempty"`

		// XpReasons Object containing information on the sources of this player's experience
		XpReasons *map[string]interface{} `json:"xp_reasons,omitempty"`

		// XpT Experience at each minute of the game
		XpT *[]int `json:"xp_t,omitempty"`
	} `json:"players,omitempty"`

	// PositiveVotes Number of positive votes the replay received in the in-game client
	PositiveVotes *int `json:"positive_votes,omitempty"`

	// RadiantGoldAdv Array of the Radiant gold advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their gold disadvantage.
	RadiantGoldAdv *[]float32 `json:"radiant_gold_adv,omitempty"`

	// RadiantScore Number of kills the Radiant team had when the match ended
	RadiantScore *int `json:"radiant_score,omitempty"`

	// RadiantTeam radiant_team
	RadiantTeam *map[string]interface{} `json:"radiant_team,omitempty"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// RadiantXpAdv Array of the Radiant experience advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their experience disadvantage.
	RadiantXpAdv *[]float32 `json:"radiant_xp_adv,omitempty"`

	// Region Integer corresponding to the region the game was played on
	Region *int `json:"region,omitempty"`

	// ReplaySalt replay_salt
	ReplaySalt *int `json:"replay_salt,omitempty"`

	// ReplayUrl replay_url
	ReplayUrl *string `json:"replay_url,omitempty"`

	// SeriesId series_id
	SeriesId *int `json:"series_id,omitempty"`

	// SeriesType series_type
	SeriesType *int `json:"series_type,omitempty"`

	// Skill Skill bracket assigned by Valve (Normal, High, Very High)
	Skill *int `json:"skill"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`

	// Teamfights teamfights
	Teamfights *[]map[string]interface{} `json:"teamfights"`

	// Throw Maximum gold advantage of the player's team if they lost the match
	Throw *int `json:"throw,omitempty"`

	// TowerStatusDire Bitmask. An integer that represents a binary of which Dire towers are still standing.
	TowerStatusDire *int `json:"tower_status_dire,omitempty"`

	// TowerStatusRadiant Bitmask. An integer that represents a binary of which Radiant towers are still standing.
	TowerStatusRadiant *int `json:"tower_status_radiant,omitempty"`

	// Version Parse version, used internally by OpenDota
	Version *int `json:"version,omitempty"`

	// Win Maximum gold advantage of the player's team if they won the match
	Win *int `json:"win,omitempty"`
}

// MetadataResponse defines model for MetadataResponse.
type MetadataResponse struct {
	// Banner banner
	Banner *map[string]interface{} `json:"banner"`
}

// ParsedMatchesResponse defines model for ParsedMatchesResponse.
type ParsedMatchesResponse struct {
	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`
}

// PlayerCountsResponse defines model for PlayerCountsResponse.
type PlayerCountsResponse struct {
	// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode *map[string]interface{} `json:"game_mode,omitempty"`

	// LaneRole lane_role
	LaneRole *map[string]interface{} `json:"lane_role,omitempty"`

	// LeaverStatus Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
	LeaverStatus *map[string]interface{} `json:"leaver_status,omitempty"`

	// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType *map[string]interface{} `json:"lobby_type,omitempty"`

	// Patch patch
	Patch *map[string]interface{} `json:"patch,omitempty"`

	// Region Integer corresponding to the region the game was played on
	Region *map[string]interface{} `json:"region,omitempty"`
}

// PlayerHeroesResponse hero
type PlayerHeroesResponse struct {
	// AgainstGames against_games
	AgainstGames *int `json:"against_games,omitempty"`

	// AgainstWin against_win
	AgainstWin *int `json:"against_win,omitempty"`

	// Games games
	Games *int `json:"games,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// LastPlayed last_played
	LastPlayed *int `json:"last_played,omitempty"`

	// Win win
	Win *int `json:"win,omitempty"`

	// WithGames with_games
	WithGames *int `json:"with_games,omitempty"`

	// WithWin with_win
	WithWin *int `json:"with_win,omitempty"`
}

// PlayerMatchesResponse Object containing information on the match
type PlayerMatchesResponse struct {
	// Assists Total assists the player had at the end of the game
	Assists *int `json:"assists,omitempty"`

	// AverageRank Average rank of players with public match data
	AverageRank *int `json:"average_rank"`

	// Deaths Total deaths the player had at the end of the game
	Deaths *int `json:"deaths,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode *int `json:"game_mode,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Kills Total kills the player had at the end of the game
	Kills *int `json:"kills,omitempty"`

	// LeaverStatus Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
	LeaverStatus *int `json:"leaver_status,omitempty"`

	// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType *int `json:"lobby_type,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// PartySize Size of the player's party
	PartySize *int `json:"party_size"`

	// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot *int `json:"player_slot"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// Skill Skill bracket assigned by Valve (Normal, High, Very High)
	Skill *int `json:"skill"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`

	// Version version
	Version *int `json:"version"`
}

// PlayerObjectResponse defines model for PlayerObjectResponse.
type PlayerObjectResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// Avatar Steam picture URL (small picture)
	Avatar *string `json:"avatar,omitempty"`

	// Avatarfull Steam picture URL (full picture)
	Avatarfull *string `json:"avatarfull,omitempty"`

	// Avatarmedium Steam picture URL (medium picture)
	Avatarmedium *string `json:"avatarmedium,omitempty"`

	// Cheese Amount of dollars the player has donated to OpenDota
	Cheese *int `json:"cheese,omitempty"`

	// CountryCode Player's country code
	CountryCode *string `json:"country_code,omitempty"`

	// FantasyRole Player's ingame role (core: 1 or support: 2)
	FantasyRole *int `json:"fantasy_role,omitempty"`

	// FhUnavailable Whether the refresh of player' match history failed
	FhUnavailable *bool `json:"fh_unavailable,omitempty"`

	// FullHistoryTime Date and time of last request to refresh player's match history
	FullHistoryTime *time.Time `json:"full_history_time,omitempty"`

	// IsLocked Whether the roster lock is active
	IsLocked *bool `json:"is_locked,omitempty"`

	// IsPro Whether the player is professional or not
	IsPro *bool `json:"is_pro,omitempty"`

	// LastLogin Date and time of last login to OpenDota
	LastLogin *time.Time `json:"last_login,omitempty"`

	// Loccountrycode Player's country identifier, e.g. US
	Loccountrycode *string `json:"loccountrycode,omitempty"`

	// LockedUntil When the roster lock will end
	LockedUntil *int `json:"locked_until,omitempty"`

	// Name Verified player name, e.g. 'Miracle-'
	Name *string `json:"name,omitempty"`

	// Personaname Player's Steam name
	Personaname *string `json:"personaname"`

	// Profileurl Steam profile URL
	Profileurl *string `json:"profileurl,omitempty"`

	// Steamid Player's steam identifier
	Steamid *string `json:"steamid,omitempty"`

	// TeamId Player's team identifier
	TeamId *int `json:"team_id,omitempty"`

	// TeamName Team name
	TeamName *string `json:"team_name"`

	// TeamTag Player's team shorthand tag, e.g. 'EG'
	TeamTag *string `json:"team_tag,omitempty"`
}

// PlayerPeersResponse defines model for PlayerPeersResponse.
type PlayerPeersResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// AgainstGames against_games
	AgainstGames *int `json:"against_games,omitempty"`

	// AgainstWin against_win
	AgainstWin *int `json:"against_win,omitempty"`

	// Avatar avatar
	Avatar *string `json:"avatar"`

	// Avatarfull avatarfull
	Avatarfull *string `json:"avatarfull"`

	// Games games
	Games *int `json:"games,omitempty"`

	// IsContributor is_contributor
	IsContributor *bool `json:"is_contributor,omitempty"`

	// IsSubscriber is_subscriber
	IsSubscriber *bool `json:"is_subscriber,omitempty"`

	// LastLogin last_login
	LastLogin *string `json:"last_login"`

	// LastPlayed last_played
	LastPlayed *int `json:"last_played,omitempty"`

	// Name name
	Name *string `json:"name"`

	// Personaname Player's Steam name
	Personaname *string `json:"personaname"`

	// Win win
	Win *int `json:"win,omitempty"`

	// WithGames with_games
	WithGames *int `json:"with_games,omitempty"`

	// WithGpmSum with_gpm_sum
	WithGpmSum *int `json:"with_gpm_sum,omitempty"`

	// WithWin with_win
	WithWin *int `json:"with_win,omitempty"`

	// WithXpmSum with_xpm_sum
	WithXpmSum *int `json:"with_xpm_sum,omitempty"`
}

// PlayerProsResponse defines model for PlayerProsResponse.
type PlayerProsResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// AgainstGames against_games
	AgainstGames *int `json:"against_games,omitempty"`

	// AgainstWin against_win
	AgainstWin *int `json:"against_win,omitempty"`

	// Avatar avatar
	Avatar *string `json:"avatar"`

	// Avatarfull avatarfull
	Avatarfull *string `json:"avatarfull"`

	// Avatarmedium avatarmedium
	Avatarmedium *string `json:"avatarmedium"`

	// Cheese cheese
	Cheese *int `json:"cheese"`

	// CountryCode country_code
	CountryCode *string `json:"country_code,omitempty"`

	// FantasyRole fantasy_role
	FantasyRole *int `json:"fantasy_role,omitempty"`

	// FhUnavailable fh_unavailable
	FhUnavailable *bool `json:"fh_unavailable"`

	// FullHistoryTime full_history_time
	FullHistoryTime *time.Time `json:"full_history_time"`

	// Games games
	Games *int `json:"games,omitempty"`

	// IsLocked is_locked
	IsLocked *bool `json:"is_locked,omitempty"`

	// IsPro is_pro
	IsPro *bool `json:"is_pro,omitempty"`

	// LastLogin last_login
	LastLogin *time.Time `json:"last_login"`

	// LastPlayed last_played
	LastPlayed *int `json:"last_played"`

	// Loccountrycode loccountrycode
	Loccountrycode *string `json:"loccountrycode"`

	// LockedUntil locked_until
	LockedUntil *int `json:"locked_until"`

	// Name name
	Name *string `json:"name"`

	// Profileurl profileurl
	Profileurl *string `json:"profileurl"`

	// Steamid steamid
	Steamid *string `json:"steamid"`

	// TeamId team_id
	TeamId *int `json:"team_id,omitempty"`

	// TeamName Team name
	TeamName *string `json:"team_name"`

	// TeamTag team_tag
	TeamTag *string `json:"team_tag"`

	// Win win
	Win *int `json:"win,omitempty"`

	// WithGames with_games
	WithGames *int `json:"with_games,omitempty"`

	// WithGpmSum with_gpm_sum
	WithGpmSum *int `json:"with_gpm_sum"`

	// WithWin with_win
	WithWin *int `json:"with_win,omitempty"`

	// WithXpmSum with_xpm_sum
	WithXpmSum *int `json:"with_xpm_sum"`
}

// PlayerRankingsResponse defines model for PlayerRankingsResponse.
type PlayerRankingsResponse struct {
	// Card numeric_rank
	Card *int `json:"card,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// PercentRank percent_rank
	PercentRank *float32 `json:"percent_rank,omitempty"`

	// Score Hero score
	Score *float32 `json:"score,omitempty"`
}

// PlayerRatingsResponse defines model for PlayerRatingsResponse.
type PlayerRatingsResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// CompetitiveRank competitive_rank
	CompetitiveRank *int `json:"competitive_rank,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// SoloCompetitiveRank solo_competitive_rank
	SoloCompetitiveRank *int `json:"solo_competitive_rank"`

	// Time time
	Time *int `json:"time,omitempty"`
}

// PlayerRecentMatchesResponse match
type PlayerRecentMatchesResponse struct {
	// Assists Total assists the player had at the end of the match
	Assists *int `json:"assists,omitempty"`

	// AverageRank Average rank of players with public match data
	AverageRank *int `json:"average_rank"`

	// Cluster cluster
	Cluster *int `json:"cluster,omitempty"`

	// Deaths Total deaths the player had at the end of the match
	Deaths *int `json:"deaths,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode *int `json:"game_mode,omitempty"`

	// GoldPerMin Average gold per minute of the player
	GoldPerMin *int `json:"gold_per_min,omitempty"`

	// HeroDamage Total hero damage to enemy heroes
	HeroDamage *int `json:"hero_damage,omitempty"`

	// HeroHealing Total healing of ally heroes
	HeroHealing *int `json:"hero_healing,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// IsRoaming Boolean describing whether or not the player roamed
	IsRoaming *bool `json:"is_roaming"`

	// Kills Total kills the player had at the end of the match
	Kills *int `json:"kills,omitempty"`

	// Lane Integer corresponding to which lane the player laned in for the match
	Lane *int `json:"lane"`

	// LaneRole lane_role
	LaneRole *int `json:"lane_role"`

	// LastHits Total last hits the player had at the end of the match
	LastHits *int `json:"last_hits,omitempty"`

	// LeaverStatus Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
	LeaverStatus *int `json:"leaver_status,omitempty"`

	// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType *int `json:"lobby_type,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// PartySize Size of the players party. If not in a party, will return 1.
	PartySize *int `json:"party_size"`

	// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot *int `json:"player_slot"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// Skill Skill bracket assigned by Valve (Normal, High, Very High). If the skill is unknown, will return null.
	Skill *int `json:"skill"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`

	// Version version
	Version *int `json:"version"`

	// XpPerMin Experience Per Minute obtained by the player
	XpPerMin *int `json:"xp_per_min,omitempty"`
}

// PlayerTotalsResponse defines model for PlayerTotalsResponse.
type PlayerTotalsResponse struct {
	// Field field
	Field *string `json:"field,omitempty"`

	// N number
	N *int `json:"n,omitempty"`

	// Sum sum
	Sum *float32 `json:"sum,omitempty"`
}

// PlayerWardMapResponse defines model for PlayerWardMapResponse.
type PlayerWardMapResponse struct {
	// Obs obs
	Obs *map[string]interface{} `json:"obs,omitempty"`

	// Sen sen
	Sen *map[string]interface{} `json:"sen,omitempty"`
}

// PlayerWinLossResponse defines model for PlayerWinLossResponse.
type PlayerWinLossResponse struct {
	// Lose Number of loses
	Lose *int `json:"lose,omitempty"`

	// Win Number of wins
	Win *int `json:"win,omitempty"`
}

// PlayerWordCloudResponse defines model for PlayerWordCloudResponse.
type PlayerWordCloudResponse struct {
	// AllWordCounts all_word_counts
	AllWordCounts *map[string]interface{} `json:"all_word_counts,omitempty"`

	// MyWordCounts my_word_counts
	MyWordCounts *map[string]interface{} `json:"my_word_counts,omitempty"`
}

// PlayersByRankResponse defines model for PlayersByRankResponse.
type PlayersByRankResponse = []struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// FhUnavailable Indicates if we were unable to fetch full history for this player due to privacy settings
	FhUnavailable *bool `json:"fh_unavailable"`

	// RankTier Integer indicating the rank/medal of the player
	RankTier *float32 `json:"rank_tier,omitempty"`
}

// PlayersResponse defines model for PlayersResponse.
type PlayersResponse struct {
	// CompetitiveRank competitive_rank
	CompetitiveRank *int `json:"competitive_rank"`

	// LeaderboardRank leaderboard_rank
	LeaderboardRank *float32 `json:"leaderboard_rank"`

	// MmrEstimate mmr_estimate
	MmrEstimate *struct {
		// Estimate estimate
		Estimate *float32 `json:"estimate"`
	} `json:"mmr_estimate,omitempty"`

	// Profile profile
	Profile *struct {
		// AccountId The player account ID
		AccountId *int `json:"account_id,omitempty"`

		// Avatar avatar
		Avatar *string `json:"avatar"`

		// Avatarfull avatarfull
		Avatarfull *string `json:"avatarfull"`

		// Avatarmedium avatarmedium
		Avatarmedium *string `json:"avatarmedium"`

		// Cheese cheese
		Cheese *int `json:"cheese"`

		// IsContributor Boolean indicating if the user contributed to the development of OpenDota
		IsContributor *bool `json:"is_contributor,omitempty"`

		// IsSubscriber Boolean indicating if the user subscribed to OpenDota
		IsSubscriber *bool `json:"is_subscriber,omitempty"`

		// LastLogin last_login
		LastLogin *string `json:"last_login"`

		// Loccountrycode loccountrycode
		Loccountrycode *string `json:"loccountrycode"`

		// Name name
		Name *string `json:"name"`

		// Personaname Player's Steam name
		Personaname *string `json:"personaname"`

		// Plus Boolean indicating status of current Dota Plus subscription
		Plus *bool `json:"plus,omitempty"`

		// Profileurl profileurl
		Profileurl *string `json:"profileurl"`

		// Steamid steamid
		Steamid *string `json:"steamid"`
	} `json:"profile,omitempty"`

	// RankTier rank_tier
	RankTier *float32 `json:"rank_tier"`

	// SoloCompetitiveRank solo_competitive_rank
	SoloCompetitiveRank *int `json:"solo_competitive_rank"`
}

// PublicMatchesResponse defines model for PublicMatchesResponse.
type PublicMatchesResponse struct {
	AvgMmr      *int `json:"avg_mmr,omitempty"`
	AvgRankTier *int `json:"avg_rank_tier,omitempty"`
	Cluster     *int `json:"cluster,omitempty"`

	// DireTeam dire_team
	DireTeam *string `json:"dire_team,omitempty"`

	// Duration Duration of the game in seconds
	Duration  *int `json:"duration,omitempty"`
	GameMode  *int `json:"game_mode,omitempty"`
	LobbyType *int `json:"lobby_type,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// MatchSeqNum match_seq_num
	MatchSeqNum *int `json:"match_seq_num,omitempty"`
	NumMmr      *int `json:"num_mmr,omitempty"`
	NumRankTier *int `json:"num_rank_tier,omitempty"`

	// RadiantTeam radiant_team
	RadiantTeam *string `json:"radiant_team,omitempty"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`
}

// RankingsResponse defines model for RankingsResponse.
type RankingsResponse struct {
	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Rankings rankings
	Rankings *[]struct {
		// AccountId The player account ID
		AccountId *int `json:"account_id,omitempty"`

		// Avatar avatar
		Avatar *string `json:"avatar"`

		// Avatarfull avatarfull
		Avatarfull *string `json:"avatarfull"`

		// Avatarmedium avatarmedium
		Avatarmedium *string `json:"avatarmedium"`

		// Cheese cheese
		Cheese *int `json:"cheese"`

		// FhUnavailable fh_unavailable
		FhUnavailable *bool `json:"fh_unavailable"`

		// FullHistoryTime full_history_time
		FullHistoryTime *time.Time `json:"full_history_time,omitempty"`

		// LastLogin last_login
		LastLogin *time.Time `json:"last_login"`

		// Loccountrycode loccountrycode
		Loccountrycode *string `json:"loccountrycode"`

		// Personaname Player's Steam name
		Personaname *string `json:"personaname"`

		// Profileurl profileurl
		Profileurl *string `json:"profileurl"`

		// RankTier rank_tier
		RankTier *int `json:"rank_tier"`

		// Score Score
		Score *float32 `json:"score,omitempty"`

		// Steamid steamid
		Steamid *string `json:"steamid"`
	} `json:"rankings,omitempty"`
}

// RecordsResponse defines model for RecordsResponse.
type RecordsResponse struct {
	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// Score Record score
	Score *int `json:"score,omitempty"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`
}

// ReplaysResponse defines model for ReplaysResponse.
type ReplaysResponse struct {
	// Cluster cluster
	Cluster *int `json:"cluster,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// ReplaySalt replay_salt
	ReplaySalt *int `json:"replay_salt,omitempty"`
}

// ScenarioItemTimingsResponse defines model for ScenarioItemTimingsResponse.
type ScenarioItemTimingsResponse struct {
	// Games The number of games where the hero bought this item before this time
	Games *string `json:"games,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Item Purchased item
	Item *string `json:"item,omitempty"`

	// Time Ingame time in seconds before the item was purchased
	Time *int `json:"time,omitempty"`

	// Wins The number of games won where the hero bought this item before this time
	Wins *string `json:"wins,omitempty"`
}

// ScenarioLaneRolesResponse defines model for ScenarioLaneRolesResponse.
type ScenarioLaneRolesResponse struct {
	// Games The number of games where the hero played in this lane role
	Games *string `json:"games,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// LaneRole The hero's lane role
	LaneRole *int `json:"lane_role,omitempty"`

	// Time Maximum game length in seconds
	Time *int `json:"time,omitempty"`

	// Wins The number of games won where the hero played in this lane role
	Wins *string `json:"wins,omitempty"`
}

// ScenarioMiscResponse defines model for ScenarioMiscResponse.
type ScenarioMiscResponse struct {
	// Games The number of games where this scenario occurred
	Games *string `json:"games,omitempty"`

	// IsRadiant Boolean indicating whether Radiant executed this scenario
	IsRadiant *bool `json:"is_radiant,omitempty"`

	// Region Region the game was played in
	Region *int `json:"region,omitempty"`

	// Scenario The scenario's name or description
	Scenario *string `json:"scenario,omitempty"`

	// Wins The number of games won where this scenario occured
	Wins *string `json:"wins,omitempty"`
}

// SchemaResponse defines model for SchemaResponse.
type SchemaResponse struct {
	// ColumnName column_name
	ColumnName *string `json:"column_name,omitempty"`

	// DataType data_type
	DataType *string `json:"data_type,omitempty"`

	// TableName table_name
	TableName *string `json:"table_name,omitempty"`
}

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// Avatarfull avatarfull
	Avatarfull *string `json:"avatarfull"`

	// LastMatchTime last_match_time. May not be present or null.
	LastMatchTime *string `json:"last_match_time,omitempty"`

	// Personaname Player's Steam name
	Personaname *string `json:"personaname"`

	// Similarity similarity
	Similarity *float32 `json:"similarity,omitempty"`
}

// TeamHeroesResponse defines model for TeamHeroesResponse.
type TeamHeroesResponse struct {
	// GamesPlayed Number of games played
	GamesPlayed *int `json:"games_played,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Name Hero name
	Name *string `json:"name,omitempty"`

	// Wins Number of wins
	Wins *int `json:"wins,omitempty"`
}

// TeamMatchObjectResponse defines model for TeamMatchObjectResponse.
type TeamMatchObjectResponse struct {
	// Cluster cluster
	Cluster *int `json:"cluster,omitempty"`

	// DireScore Number of kills the Dire team had when the match ended
	DireScore *int `json:"dire_score,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// LeagueName Name of league the match took place in
	LeagueName *string `json:"league_name,omitempty"`

	// Leagueid Identifier for the league the match took place in
	Leagueid *int `json:"leagueid,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// OpposingTeamId Opposing team identifier
	OpposingTeamId *int `json:"opposing_team_id,omitempty"`

	// OpposingTeamLogo Opposing team logo url
	OpposingTeamLogo *string `json:"opposing_team_logo,omitempty"`

	// OpposingTeamName Opposing team name, e.g. 'Evil Geniuses'
	OpposingTeamName *string `json:"opposing_team_name"`

	// Radiant Whether the team/player/hero was on Radiant
	Radiant *bool `json:"radiant,omitempty"`

	// RadiantScore Number of kills the Radiant team had when the match ended
	RadiantScore *int `json:"radiant_score,omitempty"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`
}

// TeamObjectResponse defines model for TeamObjectResponse.
type TeamObjectResponse struct {
	// LastMatchTime The Unix timestamp of the last match played by this team
	LastMatchTime *int `json:"last_match_time,omitempty"`

	// Losses The number of losses by this team
	Losses *int `json:"losses,omitempty"`

	// Name Team name
	Name *string `json:"name"`

	// Rating The Elo rating of the team
	Rating *float32 `json:"rating,omitempty"`

	// Tag The team tag/abbreviation
	Tag *string `json:"tag,omitempty"`

	// TeamId Team's identifier
	TeamId *int `json:"team_id,omitempty"`

	// Wins The number of games won by this team
	Wins *int `json:"wins,omitempty"`
}

// TeamPlayersResponse defines model for TeamPlayersResponse.
type TeamPlayersResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// GamesPlayed Number of games played
	GamesPlayed *int `json:"games_played,omitempty"`

	// IsCurrentTeamMember If this player is on the current roster
	IsCurrentTeamMember *bool `json:"is_current_team_member,omitempty"`

	// Name name
	Name *string `json:"name"`

	// Wins Number of wins
	Wins *int `json:"wins,omitempty"`
}

// AccountIdParam defines model for accountIdParam.
type AccountIdParam = int

// AgainstHeroIdParam defines model for againstHeroIdParam.
type AgainstHeroIdParam = int

// DateParam defines model for dateParam.
type DateParam = int

// ExcludedAccountIdParam defines model for excludedAccountIdParam.
type ExcludedAccountIdParam = int

// FieldParam defines model for fieldParam.
type FieldParam = string

// GameModeParam defines model for gameModeParam.
type GameModeParam = int

// HavingParam defines model for havingParam.
type HavingParam = int

// HeroIdParam defines model for heroIdParam.
type HeroIdParam = int

// HeroIdPathParam defines model for heroIdPathParam.
type HeroIdPathParam = int

// IncludedAccountIdParam defines model for includedAccountIdParam.
type IncludedAccountIdParam = int

// IsRadiantParam defines model for isRadiantParam.
type IsRadiantParam = int

// LaneRoleParam defines model for laneRoleParam.
type LaneRoleParam = int

// LeagueIdPathParam defines model for leagueIdPathParam.
type LeagueIdPathParam = int

// LessThanMatchIdParam defines model for lessThanMatchIdParam.
type LessThanMatchIdParam = int

// LimitParam defines model for limitParam.
type LimitParam = int

// LobbyTypeParam defines model for lobbyTypeParam.
type LobbyTypeParam = int

// MatchIdParam defines model for matchIdParam.
type MatchIdParam = int

// MaxRankParam defines model for maxRankParam.
type MaxRankParam = int

// MinRankParam defines model for minRankParam.
type MinRankParam = int

// MmrAscendingParam defines model for mmrAscendingParam.
type MmrAscendingParam = int

// MmrDescendingParam defines model for mmrDescendingParam.
type MmrDescendingParam = int

// OffsetParam defines model for offsetParam.
type OffsetParam = int

// PatchParam defines model for patchParam.
type PatchParam = int

// ProjectParam defines model for projectParam.
type ProjectParam = string

// RegionParam defines model for regionParam.
type RegionParam = int

// ScenarioParam defines model for scenarioParam.
type ScenarioParam = string

// SignificantParam defines model for significantParam.
type SignificantParam = int

// SortParam defines model for sortParam.
type SortParam = string

// TeamIdPathParam defines model for teamIdPathParam.
type TeamIdPathParam = int

// WinParam defines model for winParam.
type WinParam = int

// WithHeroIdParam defines model for withHeroIdParam.
type WithHeroIdParam = int

// GetBenchmarksParams defines parameters for GetBenchmarks.
type GetBenchmarksParams struct {
	// HeroId Hero ID
	HeroId string `form:"hero_id" json:"hero_id"`
}

// GetExplorerParams defines parameters for GetExplorer.
type GetExplorerParams struct {
	// Sql The PostgreSQL query as percent-encoded string.
	Sql *string `form:"sql,omitempty" json:"sql,omitempty"`
}

// GetFindMatchesParams defines parameters for GetFindMatches.
type GetFindMatchesParams struct {
	// TeamA Hero IDs on first team (array)
	TeamA *[]int `form:"teamA,omitempty" json:"teamA,omitempty"`

	// TeamB Hero IDs on second team (array)
	TeamB *[]int `form:"teamB,omitempty" json:"teamB,omitempty"`
}

// GetParsedMatchesParams defines parameters for GetParsedMatches.
type GetParsedMatchesParams struct {
	// LessThanMatchId Get matches with a match ID lower than this value
	LessThanMatchId *LessThanMatchIdParam `form:"less_than_match_id,omitempty" json:"less_than_match_id,omitempty"`
}

// GetPlayersByAccountIdSelectCountsParams defines parameters for GetPlayersByAccountIdSelectCounts.
type GetPlayersByAccountIdSelectCountsParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectHeroesParams defines parameters for GetPlayersByAccountIdSelectHeroes.
type GetPlayersByAccountIdSelectHeroesParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdHistogramsByFieldParams defines parameters for GetPlayersByAccountIdHistogramsByField.
type GetPlayersByAccountIdHistogramsByFieldParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectMatchesParams defines parameters for GetPlayersByAccountIdSelectMatches.
type GetPlayersByAccountIdSelectMatchesParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Project Fields to project (array)
	Project *ProjectParam `form:"project,omitempty" json:"project,omitempty"`
}

// GetPlayersByAccountIdSelectPeersParams defines parameters for GetPlayersByAccountIdSelectPeers.
type GetPlayersByAccountIdSelectPeersParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectProsParams defines parameters for GetPlayersByAccountIdSelectPros.
type GetPlayersByAccountIdSelectProsParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectTotalsParams defines parameters for GetPlayersByAccountIdSelectTotals.
type GetPlayersByAccountIdSelectTotalsParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectWardmapParams defines parameters for GetPlayersByAccountIdSelectWardmap.
type GetPlayersByAccountIdSelectWardmapParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectWlParams defines parameters for GetPlayersByAccountIdSelectWl.
type GetPlayersByAccountIdSelectWlParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectWordcloudParams defines parameters for GetPlayersByAccountIdSelectWordcloud.
type GetPlayersByAccountIdSelectWordcloudParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetProMatchesParams defines parameters for GetProMatches.
type GetProMatchesParams struct {
	// LessThanMatchId Get matches with a match ID lower than this value
	LessThanMatchId *LessThanMatchIdParam `form:"less_than_match_id,omitempty" json:"less_than_match_id,omitempty"`
}

// GetPublicMatchesParams defines parameters for GetPublicMatches.
type GetPublicMatchesParams struct {
	// LessThanMatchId Get matches with a match ID lower than this value
	LessThanMatchId *LessThanMatchIdParam `form:"less_than_match_id,omitempty" json:"less_than_match_id,omitempty"`

	// MinRank Minimum rank for the matches. Ranks are represented by integers (10-15: Herald, 20-25: Guardian, 30-35: Crusader, 40-45: Archon, 50-55: Legend, 60-65: Ancient, 70-75: Divine, 80-85: Immortal). Each increment represents an additional star.
	MinRank *MinRankParam `form:"min_rank,omitempty" json:"min_rank,omitempty"`

	// MaxRank Maximum rank for the matches. Ranks are represented by integers (10-15: Herald, 20-25: Guardian, 30-35: Crusader, 40-45: Archon, 50-55: Legend, 60-65: Ancient, 70-75: Divine, 80-85: Immortal). Each increment represents an additional star.
	MaxRank *MaxRankParam `form:"max_rank,omitempty" json:"max_rank,omitempty"`

	// MmrAscending Order by MMR ascending
	MmrAscending *MmrAscendingParam `form:"mmr_ascending,omitempty" json:"mmr_ascending,omitempty"`

	// MmrDescending Order by MMR descending
	MmrDescending *MmrDescendingParam `form:"mmr_descending,omitempty" json:"mmr_descending,omitempty"`
}

// GetRankingsParams defines parameters for GetRankings.
type GetRankingsParams struct {
	// HeroId Hero ID
	HeroId string `form:"hero_id" json:"hero_id"`
}

// GetScenariosItemTimingsParams defines parameters for GetScenariosItemTimings.
type GetScenariosItemTimingsParams struct {
	// Item Filter by item name e.g. "spirit_vessel"
	Item *string `form:"item,omitempty" json:"item,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`
}

// GetScenariosLaneRolesParams defines parameters for GetScenariosLaneRoles.
type GetScenariosLaneRolesParams struct {
	// LaneRole Filter by lane role 1-4 (Safe, Mid, Off, Jungle)
	LaneRole *string `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`
}

// GetScenariosMiscParams defines parameters for GetScenariosMisc.
type GetScenariosMiscParams struct {
	// Scenario pos_chat_1min,neg_chat_1min,courier_kill,first_blood
	Scenario *ScenarioParam `form:"scenario,omitempty" json:"scenario,omitempty"`
}

// GetSearchParams defines parameters for GetSearch.
type GetSearchParams struct {
	// Q Search string
	Q string `form:"q" json:"q"`
}

// GetTeamsParams defines parameters for GetTeams.
type GetTeamsParams struct {
	// Page Page number, zero indexed. Each page returns up to 1000 entries.
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}
