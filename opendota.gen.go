// Package main provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.2 DO NOT EDIT.
package main

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// BenchmarksResponse defines model for BenchmarksResponse.
type BenchmarksResponse struct {
	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Result result
	Result *struct {
		GoldPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"gold_per_min,omitempty"`
		HeroDamagePerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"hero_damage_per_min,omitempty"`
		HeroHealingPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"hero_healing_per_min,omitempty"`
		KillsPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"kills_per_min,omitempty"`
		LastHitsPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"last_hits_per_min,omitempty"`
		TowerDamage *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *int `json:"value,omitempty"`
		} `json:"tower_damage,omitempty"`
		XpPerMin *[]struct {
			// Percentile percentile
			Percentile *float32 `json:"percentile,omitempty"`

			// Value value
			Value *float32 `json:"value,omitempty"`
		} `json:"xp_per_min,omitempty"`
	} `json:"result,omitempty"`
}

// DistributionsResponse defines model for DistributionsResponse.
type DistributionsResponse struct {
	// CountryMmr country_mmr
	CountryMmr *struct {
		// Commmand command
		Commmand *string `json:"commmand,omitempty"`

		// Fields fields
		Fields *[]struct {
			// ColumnID columnID
			ColumnID *int `json:"columnID,omitempty"`

			// DataTypeID dataTypeID
			DataTypeID *int `json:"dataTypeID,omitempty"`

			// DataTypeModifier dataTypeModifier
			DataTypeModifier *int `json:"dataTypeModifier,omitempty"`

			// DataTypeSize dataTypeSize
			DataTypeSize *int `json:"dataTypeSize,omitempty"`

			// Format format
			Format *string `json:"format,omitempty"`

			// Name Field name
			Name *string `json:"name,omitempty"`

			// TableID tableID
			TableID *int `json:"tableID,omitempty"`
		} `json:"fields,omitempty"`

		// RowAsArray rowAsArray
		RowAsArray *bool `json:"rowAsArray,omitempty"`

		// RowCount rowCount
		RowCount *int `json:"rowCount,omitempty"`

		// Rows rows
		Rows *[]struct {
			// Avg avg
			Avg *string `json:"avg,omitempty"`

			// Common common
			Common *string `json:"common,omitempty"`

			// Count count
			Count *int `json:"count,omitempty"`

			// Loccountrycode loccountrycode
			Loccountrycode *string `json:"loccountrycode"`
		} `json:"rows,omitempty"`
	} `json:"country_mmr,omitempty"`

	// Mmr mmr
	Mmr *struct {
		// Commmand command
		Commmand *string `json:"commmand,omitempty"`

		// Fields fields
		Fields *[]struct {
			// ColumnID columnID
			ColumnID *int `json:"columnID,omitempty"`

			// DataTypeID dataTypeID
			DataTypeID *int `json:"dataTypeID,omitempty"`

			// DataTypeModifier dataTypeModifier
			DataTypeModifier *int `json:"dataTypeModifier,omitempty"`

			// DataTypeSize dataTypeSize
			DataTypeSize *int `json:"dataTypeSize,omitempty"`

			// Format format
			Format *string `json:"format,omitempty"`

			// Name Field name
			Name *string `json:"name,omitempty"`

			// TableID tableID
			TableID *int `json:"tableID,omitempty"`
		} `json:"fields,omitempty"`

		// RowAsArray rowAsArray
		RowAsArray *bool `json:"rowAsArray,omitempty"`

		// RowCount rowCount
		RowCount *int `json:"rowCount,omitempty"`

		// Rows rows
		Rows *[]struct {
			// Bin bin
			Bin *int `json:"bin,omitempty"`

			// BinName bin_name
			BinName *int `json:"bin_name,omitempty"`

			// Count count
			Count *int `json:"count,omitempty"`

			// CumulativeSum cumulative_sum
			CumulativeSum *int `json:"cumulative_sum,omitempty"`
		} `json:"rows,omitempty"`

		// Sum sum
		Sum *struct {
			// Count count
			Count *int `json:"count,omitempty"`
		} `json:"sum,omitempty"`
	} `json:"mmr,omitempty"`

	// Ranks ranks
	Ranks *struct {
		// Commmand command
		Commmand *string `json:"commmand,omitempty"`

		// Fields fields
		Fields *[]struct {
			// ColumnID columnID
			ColumnID *int `json:"columnID,omitempty"`

			// DataTypeID dataTypeID
			DataTypeID *int `json:"dataTypeID,omitempty"`

			// DataTypeModifier dataTypeModifier
			DataTypeModifier *int `json:"dataTypeModifier,omitempty"`

			// DataTypeSize dataTypeSize
			DataTypeSize *int `json:"dataTypeSize,omitempty"`

			// Format format
			Format *string `json:"format,omitempty"`

			// Name Field name
			Name *string `json:"name,omitempty"`

			// TableID tableID
			TableID *int `json:"tableID,omitempty"`
		} `json:"fields,omitempty"`

		// RowAsArray rowAsArray
		RowAsArray *bool `json:"rowAsArray,omitempty"`

		// RowCount rowCount
		RowCount *int `json:"rowCount,omitempty"`

		// Rows rows
		Rows *[]struct {
			// Bin bin
			Bin *int `json:"bin,omitempty"`

			// BinName bin_name
			BinName *int `json:"bin_name,omitempty"`

			// Count count
			Count *int `json:"count,omitempty"`

			// CumulativeSum cumulative_sum
			CumulativeSum *int `json:"cumulative_sum,omitempty"`
		} `json:"rows,omitempty"`

		// Sum sum
		Sum *struct {
			// Count count
			Count *int `json:"count,omitempty"`
		} `json:"sum,omitempty"`
	} `json:"ranks,omitempty"`
}

// HeroDurationsResponse defines model for HeroDurationsResponse.
type HeroDurationsResponse struct {
	// DurationBin Lower bound of number of seconds the match lasted
	DurationBin *string `json:"duration_bin,omitempty"`

	// GamesPlayed Number of games played
	GamesPlayed *int `json:"games_played,omitempty"`

	// Wins Number of wins
	Wins *int `json:"wins,omitempty"`
}

// HeroItemPopularityResponse defines model for HeroItemPopularityResponse.
type HeroItemPopularityResponse struct {
	// EarlyGameItems Items bought in the first 10 min of the game, with cost at least 700
	EarlyGameItems *struct {
		// Item Number of item bought
		Item *int `json:"item,omitempty"`
	} `json:"early_game_items,omitempty"`

	// LateGameItems Items bought at least 25 min after game started, with cost at least 4000
	LateGameItems *struct {
		// Item Number of item bought
		Item *int `json:"item,omitempty"`
	} `json:"late_game_items,omitempty"`

	// MidGameItems Items bought between 10 and 25 min of the game, with cost at least 2000
	MidGameItems *struct {
		// Item Number of item bought
		Item *int `json:"item,omitempty"`
	} `json:"mid_game_items,omitempty"`

	// StartGameItems Items bought before game started
	StartGameItems *struct {
		// Item Number of item bought
		Item *int `json:"item,omitempty"`
	} `json:"start_game_items,omitempty"`
}

// HeroMatchupsResponse defines model for HeroMatchupsResponse.
type HeroMatchupsResponse struct {
	// GamesPlayed Number of games played
	GamesPlayed *int `json:"games_played,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Wins Number of games won
	Wins *int `json:"wins,omitempty"`
}

// HeroObjectResponse defines model for HeroObjectResponse.
type HeroObjectResponse struct {
	// AttackType Hero attack type, either 'Melee' or 'Ranged'
	AttackType *string `json:"attack_type,omitempty"`

	// Id The ID value of the hero played
	Id int `json:"id"`

	// LocalizedName Hero name
	LocalizedName *string `json:"localized_name,omitempty"`

	// Name Dota hero command name
	Name *string `json:"name,omitempty"`

	// PrimaryAttr Hero primary shorthand attribute name, e.g. 'agi'
	PrimaryAttr *string   `json:"primary_attr,omitempty"`
	Roles       *[]string `json:"roles,omitempty"`
}

// HeroStatsResponse defines model for HeroStatsResponse.
type HeroStatsResponse struct {
	// N1Pick Herald picks
	N1Pick *int `json:"1_pick,omitempty"`

	// N1Win Herald wins
	N1Win *int `json:"1_win,omitempty"`

	// N2Pick Guardian picks
	N2Pick *int `json:"2_pick,omitempty"`

	// N2Win Guardian wins
	N2Win *int `json:"2_win,omitempty"`

	// N3Pick Crusader picks
	N3Pick *int `json:"3_pick,omitempty"`

	// N3Win Crusader wins
	N3Win *int `json:"3_win,omitempty"`

	// N4Pick Archon picks
	N4Pick *int `json:"4_pick,omitempty"`

	// N4Win Archon wins
	N4Win *int `json:"4_win,omitempty"`

	// N5Pick Legend picks
	N5Pick *int `json:"5_pick,omitempty"`

	// N5Win Legend wins
	N5Win *int `json:"5_win,omitempty"`

	// N6Pick Ancient picks
	N6Pick *int `json:"6_pick,omitempty"`

	// N6Win Ancient wins
	N6Win *int `json:"6_win,omitempty"`

	// N7Pick Divine picks
	N7Pick *int `json:"7_pick,omitempty"`

	// N7Win Divine wins
	N7Win *int `json:"7_win,omitempty"`

	// N8Pick Immortal picks
	N8Pick *int `json:"8_pick,omitempty"`

	// N8Win Immortal wins
	N8Win *int `json:"8_win,omitempty"`

	// AgiGain agi_gain
	AgiGain *float32 `json:"agi_gain,omitempty"`

	// AttackPoint attack_point
	AttackPoint *float32 `json:"attack_point,omitempty"`

	// AttackRange attack_range
	AttackRange *int `json:"attack_range,omitempty"`

	// AttackRate attack_rate
	AttackRate *float32 `json:"attack_rate,omitempty"`

	// AttackType attack_type
	AttackType *string `json:"attack_type,omitempty"`

	// BaseAgi base_agi
	BaseAgi *int `json:"base_agi,omitempty"`

	// BaseArmor base_armor
	BaseArmor *int `json:"base_armor,omitempty"`

	// BaseAttackMax base_attack_max
	BaseAttackMax *int `json:"base_attack_max,omitempty"`

	// BaseAttackMin base_attack_min
	BaseAttackMin *int `json:"base_attack_min,omitempty"`

	// BaseAttackTime base_attack_time
	BaseAttackTime *int `json:"base_attack_time,omitempty"`

	// BaseHealth base_health
	BaseHealth *int `json:"base_health,omitempty"`

	// BaseHealthRegen base_health_regen
	BaseHealthRegen *float32 `json:"base_health_regen,omitempty"`

	// BaseInt base_int
	BaseInt *int `json:"base_int,omitempty"`

	// BaseMana base_mana
	BaseMana *int `json:"base_mana,omitempty"`

	// BaseManaRegen base_mana_regen
	BaseManaRegen *int `json:"base_mana_regen,omitempty"`

	// BaseMr base_mr
	BaseMr *int `json:"base_mr,omitempty"`

	// BaseStr base_str
	BaseStr *int `json:"base_str,omitempty"`

	// CmEnabled cm_enabled
	CmEnabled *bool `json:"cm_enabled,omitempty"`

	// DayVision day_vision
	DayVision *int `json:"day_vision,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Icon icon
	Icon *string `json:"icon,omitempty"`

	// Id The ID value of the hero played
	Id *int `json:"id,omitempty"`

	// Img img
	Img *string `json:"img,omitempty"`

	// IntGain int_gain
	IntGain *float32 `json:"int_gain,omitempty"`

	// Legs legs
	Legs *int `json:"legs,omitempty"`

	// LocalizedName Hero name
	LocalizedName *string `json:"localized_name,omitempty"`

	// MoveSpeed move_speed
	MoveSpeed *int `json:"move_speed,omitempty"`

	// Name Dota hero command name
	Name *string `json:"name,omitempty"`

	// NightVision night_vision
	NightVision *int `json:"night_vision,omitempty"`

	// NullPick null_pick
	NullPick *int `json:"null_pick,omitempty"`

	// NullWin null_win
	NullWin *int `json:"null_win,omitempty"`

	// PrimaryAttr primary_attr
	PrimaryAttr *string `json:"primary_attr,omitempty"`

	// ProBan pro_ban
	ProBan *int `json:"pro_ban,omitempty"`

	// ProPick pro_pick
	ProPick *int `json:"pro_pick,omitempty"`

	// ProWin pro_win
	ProWin *int `json:"pro_win,omitempty"`

	// ProjectileSpeed projectile_speed
	ProjectileSpeed *int `json:"projectile_speed,omitempty"`

	// Roles roles
	Roles *[]string `json:"roles,omitempty"`

	// StrGain str_gain
	StrGain *float32 `json:"str_gain,omitempty"`

	// TurboPicks Picks in Turbo mode this month
	TurboPicks *int `json:"turbo_picks,omitempty"`

	// TurboWins Wins in Turbo mode this month
	TurboWins *int `json:"turbo_wins,omitempty"`

	// TurnRate turn_rate
	TurnRate *float32 `json:"turn_rate,omitempty"`
}

// LeagueObjectResponse defines model for LeagueObjectResponse.
type LeagueObjectResponse struct {
	// Banner banner
	Banner *string `json:"banner,omitempty"`

	// Leagueid leagueid
	Leagueid *int `json:"leagueid,omitempty"`

	// Name League name
	Name *string `json:"name,omitempty"`

	// Ticket ticket
	Ticket *string `json:"ticket,omitempty"`

	// Tier tier
	Tier *string `json:"tier,omitempty"`
}

// MatchObjectResponse defines model for MatchObjectResponse.
type MatchObjectResponse struct {
	// DireName The Dire's team name
	DireName *string `json:"dire_name,omitempty"`

	// DireScore Number of kills the Dire team had when the match ended
	DireScore *int `json:"dire_score,omitempty"`

	// DireTeamId The Dire's team_id
	DireTeamId *int `json:"dire_team_id,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// LeagueName Name of league the match took place in
	LeagueName *string `json:"league_name,omitempty"`

	// Leagueid Identifier for the league the match took place in
	Leagueid *int `json:"leagueid,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// Radiant Whether the team/player/hero was on Radiant
	Radiant *bool `json:"radiant,omitempty"`

	// RadiantName The Radiant's team name
	RadiantName *string `json:"radiant_name,omitempty"`

	// RadiantScore Number of kills the Radiant team had when the match ended
	RadiantScore *int `json:"radiant_score,omitempty"`

	// RadiantTeamId The Radiant's team_id
	RadiantTeamId *int `json:"radiant_team_id,omitempty"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// SeriesId Identifier for the series of the match
	SeriesId *int `json:"series_id,omitempty"`

	// SeriesType Type of series the match was
	SeriesType *int `json:"series_type,omitempty"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`
}

// MatchResponse defines model for MatchResponse.
type MatchResponse struct {
	// AllWordCounts Word counts of the all chat messages in the player's games
	AllWordCounts *map[string]interface{} `json:"all_word_counts,omitempty"`

	// BarracksStatusDire Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game.
	BarracksStatusDire *int `json:"barracks_status_dire,omitempty"`

	// BarracksStatusRadiant Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game.
	BarracksStatusRadiant *int `json:"barracks_status_radiant,omitempty"`

	// Chat Array containing information on the chat of the game
	Chat *[]struct {
		// Key The message the player sent
		Key *string `json:"key,omitempty"`

		// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
		PlayerSlot *int `json:"player_slot"`

		// Slot slot
		Slot *int `json:"slot,omitempty"`

		// Time Time in seconds at which the message was said
		Time *int `json:"time,omitempty"`

		// Unit Name of the player who sent the message
		Unit *string `json:"unit,omitempty"`
	} `json:"chat,omitempty"`

	// Cluster cluster
	Cluster *int `json:"cluster,omitempty"`

	// Comeback Maximum gold disadvantage of the player's team if they won the match
	Comeback *int `json:"comeback,omitempty"`

	// Cosmetics cosmetics
	Cosmetics *map[string]int `json:"cosmetics,omitempty"`

	// DireScore Number of kills the Dire team had when the match ended
	DireScore *int `json:"dire_score,omitempty"`

	// DireTeam dire_team
	DireTeam *map[string]interface{} `json:"dire_team,omitempty"`

	// DraftTimings draft_timings
	DraftTimings *[]struct {
		// ActiveTeam active_team
		ActiveTeam *int `json:"active_team,omitempty"`

		// ExtraTime extra_time
		ExtraTime *int `json:"extra_time,omitempty"`

		// HeroId The ID value of the hero played
		HeroId *int `json:"hero_id,omitempty"`

		// Order order
		Order *int `json:"order,omitempty"`

		// Pick pick
		Pick *bool `json:"pick,omitempty"`

		// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
		PlayerSlot *int `json:"player_slot"`

		// TotalTimeTaken total_time_taken
		TotalTimeTaken *int `json:"total_time_taken,omitempty"`
	} `json:"draft_timings,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// Engine engine
	Engine *int `json:"engine,omitempty"`

	// FirstBloodTime Time in seconds at which first blood occurred
	FirstBloodTime *int `json:"first_blood_time,omitempty"`

	// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode *int `json:"game_mode,omitempty"`

	// HumanPlayers Number of human players in the game
	HumanPlayers *int `json:"human_players,omitempty"`

	// League league
	League *map[string]interface{} `json:"league,omitempty"`

	// Leagueid leagueid
	Leagueid *int `json:"leagueid,omitempty"`

	// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType *int `json:"lobby_type,omitempty"`

	// Loss Maximum gold disadvantage of the player's team if they lost the match
	Loss *int `json:"loss,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// MatchSeqNum match_seq_num
	MatchSeqNum *int `json:"match_seq_num,omitempty"`

	// MyWordCounts Word counts of the player's all chat messages
	MyWordCounts *map[string]interface{} `json:"my_word_counts,omitempty"`

	// NegativeVotes Number of negative votes the replay received in the in-game client
	NegativeVotes *int `json:"negative_votes,omitempty"`

	// Objectives objectives
	Objectives *[]map[string]interface{} `json:"objectives,omitempty"`

	// Patch Information on the patch version the game is played on
	Patch *int `json:"patch,omitempty"`

	// PicksBans Array containing information on the draft. Each item contains a boolean relating to whether the choice is a pick or a ban, the hero ID, the team the picked or banned it, and the order.
	PicksBans *[]struct {
		// HeroId The ID value of the hero played
		HeroId *int `json:"hero_id,omitempty"`

		// IsPick Boolean indicating whether the choice is a pick or a ban
		IsPick *bool `json:"is_pick,omitempty"`

		// Order The order of the pick or ban
		Order *int `json:"order,omitempty"`

		// Team The team that picked or banned the hero
		Team *int `json:"team,omitempty"`
	} `json:"picks_bans,omitempty"`

	// Players Array of information on individual players
	Players *[]struct {
		// Abandons abandons
		Abandons *int `json:"abandons,omitempty"`

		// AbilityTargets Object containing information on who the player used their abilities on
		AbilityTargets *map[string]interface{} `json:"ability_targets,omitempty"`

		// AbilityUpgradesArr An array describing how abilities were upgraded
		AbilityUpgradesArr *[]int `json:"ability_upgrades_arr,omitempty"`

		// AbilityUses Object containing information on how many times the played used their abilities
		AbilityUses *map[string]interface{} `json:"ability_uses,omitempty"`

		// AccountId The player account ID
		AccountId *int `json:"account_id,omitempty"`

		// Actions Object containing information on how many and what type of actions the player issued to their hero
		Actions *map[string]interface{} `json:"actions,omitempty"`

		// ActionsPerMin Actions per minute
		ActionsPerMin *int `json:"actions_per_min,omitempty"`

		// AdditionalUnits Object containing information on additional units the player had under their control
		AdditionalUnits *[]map[string]interface{} `json:"additional_units"`

		// AncientKills Total number of Ancient creeps killed by the player
		AncientKills *int `json:"ancient_kills,omitempty"`

		// Assists Number of assists the player had
		Assists *int `json:"assists,omitempty"`

		// Backpack0 Item in backpack slot 0
		Backpack0 *int `json:"backpack_0,omitempty"`

		// Backpack1 Item in backpack slot 1
		Backpack1 *int `json:"backpack_1,omitempty"`

		// Backpack2 Item in backpack slot 2
		Backpack2 *int `json:"backpack_2,omitempty"`

		// Benchmarks Object containing information on certain benchmarks like GPM, XPM, KDA, tower damage, etc
		Benchmarks *map[string]interface{} `json:"benchmarks,omitempty"`

		// BuybackCount Total number of buyback the player used
		BuybackCount *int `json:"buyback_count,omitempty"`

		// BuybackLog Array containing information about buybacks
		BuybackLog *[]struct {
			// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
			PlayerSlot *int `json:"player_slot"`

			// Slot slot
			Slot *int `json:"slot,omitempty"`

			// Time Time in seconds the buyback occurred
			Time *int `json:"time,omitempty"`
		} `json:"buyback_log,omitempty"`

		// CampsStacked Number of camps stacked
		CampsStacked *int `json:"camps_stacked,omitempty"`

		// Cluster cluster
		Cluster *int `json:"cluster,omitempty"`

		// ConnectionLog Array containing information about the player's disconnections and reconnections
		ConnectionLog *[]struct {
			// Event Event that occurred
			Event *string `json:"event,omitempty"`

			// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
			PlayerSlot *int `json:"player_slot"`

			// Time Game time in seconds the event ocurred
			Time *int `json:"time,omitempty"`
		} `json:"connection_log,omitempty"`

		// Cosmetics cosmetics
		Cosmetics *[]struct {
			CreationDate    *time.Time `json:"creation_date"`
			ImageInventory  *string    `json:"image_inventory"`
			ImagePath       *string    `json:"image_path"`
			ItemDescription *string    `json:"item_description"`
			ItemId          *int       `json:"item_id,omitempty"`
			ItemName        *string    `json:"item_name,omitempty"`
			ItemRarity      *string    `json:"item_rarity"`
			ItemTypeName    *string    `json:"item_type_name"`

			// Name name
			Name         *string `json:"name"`
			Prefab       *string `json:"prefab,omitempty"`
			UsedByHeroes *string `json:"used_by_heroes"`
		} `json:"cosmetics,omitempty"`

		// CourierKills Total number of courier kills the player had
		CourierKills *int `json:"courier_kills,omitempty"`

		// CreepsStacked Number of creeps stacked
		CreepsStacked *int `json:"creeps_stacked,omitempty"`

		// Damage Object containing information about damage dealt by the player to different units
		Damage *map[string]interface{} `json:"damage,omitempty"`

		// DamageInflictor Object containing information about about the sources of this player's damage to heroes
		DamageInflictor *map[string]interface{} `json:"damage_inflictor,omitempty"`

		// DamageInflictorReceived Object containing information about the sources of damage received by this player from heroes
		DamageInflictorReceived *map[string]interface{} `json:"damage_inflictor_received,omitempty"`

		// DamageTaken Object containing information about from whom the player took damage
		DamageTaken *map[string]interface{} `json:"damage_taken,omitempty"`

		// DamageTargets Object containing information on how and how much damage the player dealt to other heroes
		DamageTargets *map[string]interface{} `json:"damage_targets,omitempty"`

		// Deaths Number of deaths
		Deaths *int `json:"deaths,omitempty"`

		// Denies Number of denies
		Denies *int `json:"denies,omitempty"`

		// DnT Array containing number of denies at different times of the match
		DnT *[]int `json:"dn_t,omitempty"`

		// Duration Duration of the game in seconds
		Duration *int `json:"duration,omitempty"`

		// FirstPurchaseTime Object with information on when the player first puchased an item
		FirstPurchaseTime *map[string]interface{} `json:"first_purchase_time,omitempty"`

		// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
		GameMode *int `json:"game_mode,omitempty"`

		// Gold Gold at the end of the game
		Gold *int `json:"gold,omitempty"`

		// GoldPerMin Gold Per Minute obtained by this player
		GoldPerMin *int `json:"gold_per_min,omitempty"`

		// GoldReasons Object containing information on how the player gainined gold over the course of the match
		GoldReasons *map[string]interface{} `json:"gold_reasons,omitempty"`

		// GoldSpent How much gold the player spent
		GoldSpent *int `json:"gold_spent,omitempty"`

		// GoldT Array containing total gold at different times of the match
		GoldT *[]int `json:"gold_t,omitempty"`

		// HeroDamage Hero Damage Dealt
		HeroDamage *int `json:"hero_damage,omitempty"`

		// HeroHealing Hero Healing Done
		HeroHealing *int `json:"hero_healing,omitempty"`

		// HeroHits Object containing information on how many ticks of damages the hero inflicted with different spells and damage inflictors
		HeroHits *map[string]interface{} `json:"hero_hits,omitempty"`

		// HeroId The ID value of the hero played
		HeroId *int `json:"hero_id,omitempty"`

		// HeroKills Total number of heroes killed by the player
		HeroKills *int `json:"hero_kills,omitempty"`

		// IsRadiant Boolean for whether or not the player is on Radiant
		IsRadiant *bool `json:"isRadiant,omitempty"`

		// IsRoaming Boolean referring to whether or not the player roamed
		IsRoaming *bool `json:"is_roaming"`

		// Item0 Item in the player's first slot
		Item0 *int `json:"item_0,omitempty"`

		// Item1 Item in the player's second slot
		Item1 *int `json:"item_1,omitempty"`

		// Item2 Item in the player's third slot
		Item2 *int `json:"item_2,omitempty"`

		// Item3 Item in the player's fourth slot
		Item3 *int `json:"item_3,omitempty"`

		// Item4 Item in the player's fifth slot
		Item4 *int `json:"item_4,omitempty"`

		// Item5 Item in the player's sixth slot
		Item5 *int `json:"item_5,omitempty"`

		// ItemUsage Object containing binary integers the tell whether the item was purchased by the player (note: this is always 1)
		ItemUsage *map[string]interface{} `json:"item_usage,omitempty"`

		// ItemUses Object containing information about how many times a player used items
		ItemUses *map[string]interface{} `json:"item_uses,omitempty"`

		// ItemWin Object with information on whether or not the item won
		ItemWin *map[string]interface{} `json:"item_win,omitempty"`

		// Kda kda
		Kda *float32 `json:"kda,omitempty"`

		// KillStreaks Object containing information about the player's killstreaks
		KillStreaks *map[string]interface{} `json:"kill_streaks,omitempty"`

		// Killed Object containing information about what units the player killed
		Killed *map[string]interface{} `json:"killed,omitempty"`

		// KilledBy Object containing information about who killed the player
		KilledBy *map[string]interface{} `json:"killed_by,omitempty"`

		// Kills Number of kills
		Kills *int `json:"kills,omitempty"`

		// KillsLog Array containing information on which hero the player killed at what time
		KillsLog *[]struct {
			// Key Hero killed
			Key *string `json:"key,omitempty"`

			// Time Time in seconds the player killed the hero
			Time *int `json:"time,omitempty"`
		} `json:"kills_log,omitempty"`

		// KillsPerMin Number of kills per minute
		KillsPerMin *float32 `json:"kills_per_min,omitempty"`

		// Lane Integer referring to which lane the hero laned in
		Lane *int `json:"lane"`

		// LaneEfficiency lane_efficiency
		LaneEfficiency *float32 `json:"lane_efficiency,omitempty"`

		// LaneEfficiencyPct lane_efficiency_pct
		LaneEfficiencyPct *float32 `json:"lane_efficiency_pct,omitempty"`

		// LaneKills Total number of lane creeps killed by the player
		LaneKills *int `json:"lane_kills,omitempty"`

		// LanePos Object containing information on lane position
		LanePos *map[string]interface{} `json:"lane_pos,omitempty"`

		// LaneRole lane_role
		LaneRole *int `json:"lane_role"`

		// LastHits Number of last hits
		LastHits *int `json:"last_hits,omitempty"`

		// LastLogin Time of player's last login
		LastLogin *time.Time `json:"last_login"`

		// LeaverStatus Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
		LeaverStatus *int `json:"leaver_status,omitempty"`

		// Level Level at the end of the game
		Level *int `json:"level,omitempty"`

		// LhT Array describing last hits at each minute in the game
		LhT *[]int `json:"lh_t,omitempty"`

		// LifeState life_state
		LifeState *map[string]interface{} `json:"life_state,omitempty"`

		// LifeStateDead life_state_dead
		LifeStateDead *int `json:"life_state_dead,omitempty"`

		// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
		LobbyType *int `json:"lobby_type,omitempty"`

		// Lose Binary integer representing whether or not the player lost
		Lose *int `json:"lose,omitempty"`

		// MatchId The ID number of the match assigned by Valve
		MatchId *int `json:"match_id,omitempty"`

		// MaxHeroHit Object with information on the highest damage instance the player inflicted
		MaxHeroHit *map[string]interface{} `json:"max_hero_hit,omitempty"`

		// MultiKills Object with information on the number of the number of multikills the player had
		MultiKills *map[string]interface{} `json:"multi_kills,omitempty"`

		// Name name
		Name *string `json:"name"`

		// NecronomiconKills Total number of Necronomicon creeps killed by the player
		NecronomiconKills *int `json:"necronomicon_kills,omitempty"`

		// NeutralKills Total number of neutral creeps killed
		NeutralKills *int `json:"neutral_kills,omitempty"`

		// Obs Object with information on where the player placed observer wards. The location takes the form (outer number, inner number) and are from ~64-192.
		Obs *map[string]interface{} `json:"obs,omitempty"`

		// ObsLeftLog obs_left_log
		ObsLeftLog *[]map[string]interface{} `json:"obs_left_log,omitempty"`

		// ObsLog Object containing information on when and where the player placed observer wards
		ObsLog *[]map[string]interface{} `json:"obs_log,omitempty"`

		// ObsPlaced Total number of observer wards placed
		ObsPlaced *int `json:"obs_placed,omitempty"`

		// ObserverKills Total number of observer wards killed by the player
		ObserverKills *int `json:"observer_kills,omitempty"`

		// ObserverUses Number of observer wards used
		ObserverUses *int `json:"observer_uses,omitempty"`

		// PartyId party_id
		PartyId *int `json:"party_id,omitempty"`

		// Patch Integer representing the patch the game was played on
		Patch *int `json:"patch,omitempty"`

		// PermanentBuffs Array describing permanent buffs the player had at the end of the game. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/permanent_buffs.json
		PermanentBuffs *[]map[string]interface{} `json:"permanent_buffs,omitempty"`

		// Personaname Player's Steam name
		Personaname *string `json:"personaname"`

		// Pings Total number of pings
		Pings *int `json:"pings,omitempty"`

		// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
		PlayerSlot *int `json:"player_slot"`

		// Purchase Object containing information on the items the player purchased
		Purchase *map[string]interface{} `json:"purchase,omitempty"`

		// PurchaseLog Object containing information on when items were purchased
		PurchaseLog *[]struct {
			// Charges Integer amount of charges
			Charges *int `json:"charges,omitempty"`

			// Key String item ID
			Key *string `json:"key,omitempty"`

			// Time Time in seconds the item was bought
			Time *int `json:"time,omitempty"`
		} `json:"purchase_log,omitempty"`

		// PurchaseTime Object with information on when the player last purchased an item
		PurchaseTime *map[string]interface{} `json:"purchase_time,omitempty"`

		// PurchaseTpscroll Total number of TP scrolls purchased by the player
		PurchaseTpscroll *int `json:"purchase_tpscroll,omitempty"`

		// RadiantWin Boolean indicating whether Radiant won the match
		RadiantWin *bool `json:"radiant_win"`

		// RankTier The rank tier of the player. Tens place indicates rank, ones place indicates stars.
		RankTier *int `json:"rank_tier,omitempty"`

		// Region Integer corresponding to the region the game was played on
		Region *int `json:"region,omitempty"`

		// RoshanKills Total number of roshan kills (last hit on roshan) the player had
		RoshanKills *int `json:"roshan_kills,omitempty"`

		// RunePickups Number of runes picked up
		RunePickups *int `json:"rune_pickups,omitempty"`

		// Runes Object with information about which runes the player picked up
		Runes *map[string]int `json:"runes,omitempty"`

		// RunesLog Array with information on when runes were picked up
		RunesLog *[]struct {
			// Key key
			Key *int `json:"key,omitempty"`

			// Time Time in seconds rune picked up
			Time *int `json:"time,omitempty"`
		} `json:"runes_log,omitempty"`

		// Sen Object with information on where sentries were placed. The location takes the form (outer number, inner number) and are from ~64-192.
		Sen *map[string]interface{} `json:"sen,omitempty"`

		// SenLeftLog Array containing information on when and where the player placed sentries
		SenLeftLog *[]map[string]interface{} `json:"sen_left_log,omitempty"`

		// SenLog Array with information on when and where sentries were placed by the player
		SenLog *[]map[string]interface{} `json:"sen_log,omitempty"`

		// SenPlaced How many sentries were placed by the player
		SenPlaced *int `json:"sen_placed,omitempty"`

		// SentryKills Total number of sentry wards killed by the player
		SentryKills *int `json:"sentry_kills,omitempty"`

		// SentryUses Number of sentry wards used
		SentryUses *int `json:"sentry_uses,omitempty"`

		// StartTime The Unix timestamp at which the game started
		StartTime *int `json:"start_time,omitempty"`

		// Stuns Total stun duration of all stuns by the player
		Stuns *float32 `json:"stuns,omitempty"`

		// Times Time in seconds corresponding to the time of entries of other arrays in the match.
		Times *[]int `json:"times,omitempty"`

		// TotalGold Total gold at the end of the game
		TotalGold *int `json:"total_gold,omitempty"`

		// TotalXp Total experience at the end of the game
		TotalXp *int `json:"total_xp,omitempty"`

		// TowerDamage Total tower damage done by the player
		TowerDamage *int `json:"tower_damage,omitempty"`

		// TowerKills Total number of tower kills the player had
		TowerKills *int `json:"tower_kills,omitempty"`

		// Win Binary integer representing whether or not the player won
		Win *int `json:"win,omitempty"`

		// XpPerMin Experience Per Minute obtained by the player
		XpPerMin *int `json:"xp_per_min,omitempty"`

		// XpReasons Object containing information on the sources of this player's experience
		XpReasons *map[string]interface{} `json:"xp_reasons,omitempty"`

		// XpT Experience at each minute of the game
		XpT *[]int `json:"xp_t,omitempty"`
	} `json:"players,omitempty"`

	// PositiveVotes Number of positive votes the replay received in the in-game client
	PositiveVotes *int `json:"positive_votes,omitempty"`

	// RadiantGoldAdv Array of the Radiant gold advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their gold disadvantage.
	RadiantGoldAdv *[]float32 `json:"radiant_gold_adv,omitempty"`

	// RadiantScore Number of kills the Radiant team had when the match ended
	RadiantScore *int `json:"radiant_score,omitempty"`

	// RadiantTeam radiant_team
	RadiantTeam *map[string]interface{} `json:"radiant_team,omitempty"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// RadiantXpAdv Array of the Radiant experience advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their experience disadvantage.
	RadiantXpAdv *[]float32 `json:"radiant_xp_adv,omitempty"`

	// Region Integer corresponding to the region the game was played on
	Region *int `json:"region,omitempty"`

	// ReplaySalt replay_salt
	ReplaySalt *int `json:"replay_salt,omitempty"`

	// ReplayUrl replay_url
	ReplayUrl *string `json:"replay_url,omitempty"`

	// SeriesId series_id
	SeriesId *int `json:"series_id,omitempty"`

	// SeriesType series_type
	SeriesType *int `json:"series_type,omitempty"`

	// Skill Skill bracket assigned by Valve (Normal, High, Very High)
	Skill *int `json:"skill"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`

	// Teamfights teamfights
	Teamfights *[]map[string]interface{} `json:"teamfights"`

	// Throw Maximum gold advantage of the player's team if they lost the match
	Throw *int `json:"throw,omitempty"`

	// TowerStatusDire Bitmask. An integer that represents a binary of which Dire towers are still standing.
	TowerStatusDire *int `json:"tower_status_dire,omitempty"`

	// TowerStatusRadiant Bitmask. An integer that represents a binary of which Radiant towers are still standing.
	TowerStatusRadiant *int `json:"tower_status_radiant,omitempty"`

	// Version Parse version, used internally by OpenDota
	Version *int `json:"version,omitempty"`

	// Win Maximum gold advantage of the player's team if they won the match
	Win *int `json:"win,omitempty"`
}

// MetadataResponse defines model for MetadataResponse.
type MetadataResponse struct {
	// Banner banner
	Banner *map[string]interface{} `json:"banner"`
}

// ParsedMatchesResponse defines model for ParsedMatchesResponse.
type ParsedMatchesResponse struct {
	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`
}

// PlayerCountsResponse defines model for PlayerCountsResponse.
type PlayerCountsResponse struct {
	// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode *map[string]interface{} `json:"game_mode,omitempty"`

	// LaneRole lane_role
	LaneRole *map[string]interface{} `json:"lane_role,omitempty"`

	// LeaverStatus Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
	LeaverStatus *map[string]interface{} `json:"leaver_status,omitempty"`

	// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType *map[string]interface{} `json:"lobby_type,omitempty"`

	// Patch patch
	Patch *map[string]interface{} `json:"patch,omitempty"`

	// Region Integer corresponding to the region the game was played on
	Region *map[string]interface{} `json:"region,omitempty"`
}

// PlayerHeroesResponse hero
type PlayerHeroesResponse struct {
	// AgainstGames against_games
	AgainstGames *int `json:"against_games,omitempty"`

	// AgainstWin against_win
	AgainstWin *int `json:"against_win,omitempty"`

	// Games games
	Games *int `json:"games,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// LastPlayed last_played
	LastPlayed *int `json:"last_played,omitempty"`

	// Win win
	Win *int `json:"win,omitempty"`

	// WithGames with_games
	WithGames *int `json:"with_games,omitempty"`

	// WithWin with_win
	WithWin *int `json:"with_win,omitempty"`
}

// PlayerMatchesResponse Object containing information on the match
type PlayerMatchesResponse struct {
	// Assists Total assists the player had at the end of the game
	Assists *int `json:"assists,omitempty"`

	// AverageRank Average rank of players with public match data
	AverageRank *int `json:"average_rank"`

	// Deaths Total deaths the player had at the end of the game
	Deaths *int `json:"deaths,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode *int `json:"game_mode,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Kills Total kills the player had at the end of the game
	Kills *int `json:"kills,omitempty"`

	// LeaverStatus Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
	LeaverStatus *int `json:"leaver_status,omitempty"`

	// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType *int `json:"lobby_type,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// PartySize Size of the player's party
	PartySize *int `json:"party_size"`

	// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot *int `json:"player_slot"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// Skill Skill bracket assigned by Valve (Normal, High, Very High)
	Skill *int `json:"skill"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`

	// Version version
	Version *int `json:"version"`
}

// PlayerObjectResponse defines model for PlayerObjectResponse.
type PlayerObjectResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// Avatar Steam picture URL (small picture)
	Avatar *string `json:"avatar,omitempty"`

	// Avatarfull Steam picture URL (full picture)
	Avatarfull *string `json:"avatarfull,omitempty"`

	// Avatarmedium Steam picture URL (medium picture)
	Avatarmedium *string `json:"avatarmedium,omitempty"`

	// Cheese Amount of dollars the player has donated to OpenDota
	Cheese *int `json:"cheese,omitempty"`

	// CountryCode Player's country code
	CountryCode *string `json:"country_code,omitempty"`

	// FantasyRole Player's ingame role (core: 1 or support: 2)
	FantasyRole *int `json:"fantasy_role,omitempty"`

	// FhUnavailable Whether the refresh of player' match history failed
	FhUnavailable *bool `json:"fh_unavailable,omitempty"`

	// FullHistoryTime Date and time of last request to refresh player's match history
	FullHistoryTime *time.Time `json:"full_history_time,omitempty"`

	// IsLocked Whether the roster lock is active
	IsLocked *bool `json:"is_locked,omitempty"`

	// IsPro Whether the player is professional or not
	IsPro *bool `json:"is_pro,omitempty"`

	// LastLogin Date and time of last login to OpenDota
	LastLogin *time.Time `json:"last_login,omitempty"`

	// Loccountrycode Player's country identifier, e.g. US
	Loccountrycode *string `json:"loccountrycode,omitempty"`

	// LockedUntil When the roster lock will end
	LockedUntil *int `json:"locked_until,omitempty"`

	// Name Verified player name, e.g. 'Miracle-'
	Name *string `json:"name,omitempty"`

	// Personaname Player's Steam name
	Personaname *string `json:"personaname"`

	// Profileurl Steam profile URL
	Profileurl *string `json:"profileurl,omitempty"`

	// Steamid Player's steam identifier
	Steamid *string `json:"steamid,omitempty"`

	// TeamId Player's team identifier
	TeamId *int `json:"team_id,omitempty"`

	// TeamName Team name
	TeamName *string `json:"team_name"`

	// TeamTag Player's team shorthand tag, e.g. 'EG'
	TeamTag *string `json:"team_tag,omitempty"`
}

// PlayerPeersResponse defines model for PlayerPeersResponse.
type PlayerPeersResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// AgainstGames against_games
	AgainstGames *int `json:"against_games,omitempty"`

	// AgainstWin against_win
	AgainstWin *int `json:"against_win,omitempty"`

	// Avatar avatar
	Avatar *string `json:"avatar"`

	// Avatarfull avatarfull
	Avatarfull *string `json:"avatarfull"`

	// Games games
	Games *int `json:"games,omitempty"`

	// IsContributor is_contributor
	IsContributor *bool `json:"is_contributor,omitempty"`

	// IsSubscriber is_subscriber
	IsSubscriber *bool `json:"is_subscriber,omitempty"`

	// LastLogin last_login
	LastLogin *string `json:"last_login"`

	// LastPlayed last_played
	LastPlayed *int `json:"last_played,omitempty"`

	// Name name
	Name *string `json:"name"`

	// Personaname Player's Steam name
	Personaname *string `json:"personaname"`

	// Win win
	Win *int `json:"win,omitempty"`

	// WithGames with_games
	WithGames *int `json:"with_games,omitempty"`

	// WithGpmSum with_gpm_sum
	WithGpmSum *int `json:"with_gpm_sum,omitempty"`

	// WithWin with_win
	WithWin *int `json:"with_win,omitempty"`

	// WithXpmSum with_xpm_sum
	WithXpmSum *int `json:"with_xpm_sum,omitempty"`
}

// PlayerProsResponse defines model for PlayerProsResponse.
type PlayerProsResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// AgainstGames against_games
	AgainstGames *int `json:"against_games,omitempty"`

	// AgainstWin against_win
	AgainstWin *int `json:"against_win,omitempty"`

	// Avatar avatar
	Avatar *string `json:"avatar"`

	// Avatarfull avatarfull
	Avatarfull *string `json:"avatarfull"`

	// Avatarmedium avatarmedium
	Avatarmedium *string `json:"avatarmedium"`

	// Cheese cheese
	Cheese *int `json:"cheese"`

	// CountryCode country_code
	CountryCode *string `json:"country_code,omitempty"`

	// FantasyRole fantasy_role
	FantasyRole *int `json:"fantasy_role,omitempty"`

	// FhUnavailable fh_unavailable
	FhUnavailable *bool `json:"fh_unavailable"`

	// FullHistoryTime full_history_time
	FullHistoryTime *time.Time `json:"full_history_time"`

	// Games games
	Games *int `json:"games,omitempty"`

	// IsLocked is_locked
	IsLocked *bool `json:"is_locked,omitempty"`

	// IsPro is_pro
	IsPro *bool `json:"is_pro,omitempty"`

	// LastLogin last_login
	LastLogin *time.Time `json:"last_login"`

	// LastPlayed last_played
	LastPlayed *int `json:"last_played"`

	// Loccountrycode loccountrycode
	Loccountrycode *string `json:"loccountrycode"`

	// LockedUntil locked_until
	LockedUntil *int `json:"locked_until"`

	// Name name
	Name *string `json:"name"`

	// Profileurl profileurl
	Profileurl *string `json:"profileurl"`

	// Steamid steamid
	Steamid *string `json:"steamid"`

	// TeamId team_id
	TeamId *int `json:"team_id,omitempty"`

	// TeamName Team name
	TeamName *string `json:"team_name"`

	// TeamTag team_tag
	TeamTag *string `json:"team_tag"`

	// Win win
	Win *int `json:"win,omitempty"`

	// WithGames with_games
	WithGames *int `json:"with_games,omitempty"`

	// WithGpmSum with_gpm_sum
	WithGpmSum *int `json:"with_gpm_sum"`

	// WithWin with_win
	WithWin *int `json:"with_win,omitempty"`

	// WithXpmSum with_xpm_sum
	WithXpmSum *int `json:"with_xpm_sum"`
}

// PlayerRankingsResponse defines model for PlayerRankingsResponse.
type PlayerRankingsResponse struct {
	// Card numeric_rank
	Card *int `json:"card,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// PercentRank percent_rank
	PercentRank *float32 `json:"percent_rank,omitempty"`

	// Score Hero score
	Score *float32 `json:"score,omitempty"`
}

// PlayerRatingsResponse defines model for PlayerRatingsResponse.
type PlayerRatingsResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// CompetitiveRank competitive_rank
	CompetitiveRank *int `json:"competitive_rank,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// SoloCompetitiveRank solo_competitive_rank
	SoloCompetitiveRank *int `json:"solo_competitive_rank"`

	// Time time
	Time *int `json:"time,omitempty"`
}

// PlayerRecentMatchesResponse match
type PlayerRecentMatchesResponse struct {
	// Assists Total assists the player had at the end of the match
	Assists *int `json:"assists,omitempty"`

	// AverageRank Average rank of players with public match data
	AverageRank *int `json:"average_rank"`

	// Cluster cluster
	Cluster *int `json:"cluster,omitempty"`

	// Deaths Total deaths the player had at the end of the match
	Deaths *int `json:"deaths,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// GameMode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode *int `json:"game_mode,omitempty"`

	// GoldPerMin Average gold per minute of the player
	GoldPerMin *int `json:"gold_per_min,omitempty"`

	// HeroDamage Total hero damage to enemy heroes
	HeroDamage *int `json:"hero_damage,omitempty"`

	// HeroHealing Total healing of ally heroes
	HeroHealing *int `json:"hero_healing,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// IsRoaming Boolean describing whether or not the player roamed
	IsRoaming *bool `json:"is_roaming"`

	// Kills Total kills the player had at the end of the match
	Kills *int `json:"kills,omitempty"`

	// Lane Integer corresponding to which lane the player laned in for the match
	Lane *int `json:"lane"`

	// LaneRole lane_role
	LaneRole *int `json:"lane_role"`

	// LastHits Total last hits the player had at the end of the match
	LastHits *int `json:"last_hits,omitempty"`

	// LeaverStatus Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
	LeaverStatus *int `json:"leaver_status,omitempty"`

	// LobbyType Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType *int `json:"lobby_type,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// PartySize Size of the players party. If not in a party, will return 1.
	PartySize *int `json:"party_size"`

	// PlayerSlot Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot *int `json:"player_slot"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// Skill Skill bracket assigned by Valve (Normal, High, Very High). If the skill is unknown, will return null.
	Skill *int `json:"skill"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`

	// Version version
	Version *int `json:"version"`

	// XpPerMin Experience Per Minute obtained by the player
	XpPerMin *int `json:"xp_per_min,omitempty"`
}

// PlayerTotalsResponse defines model for PlayerTotalsResponse.
type PlayerTotalsResponse struct {
	// Field field
	Field *string `json:"field,omitempty"`

	// N number
	N *int `json:"n,omitempty"`

	// Sum sum
	Sum *float32 `json:"sum,omitempty"`
}

// PlayerWardMapResponse defines model for PlayerWardMapResponse.
type PlayerWardMapResponse struct {
	// Obs obs
	Obs *map[string]interface{} `json:"obs,omitempty"`

	// Sen sen
	Sen *map[string]interface{} `json:"sen,omitempty"`
}

// PlayerWinLossResponse defines model for PlayerWinLossResponse.
type PlayerWinLossResponse struct {
	// Lose Number of loses
	Lose *int `json:"lose,omitempty"`

	// Win Number of wins
	Win *int `json:"win,omitempty"`
}

// PlayerWordCloudResponse defines model for PlayerWordCloudResponse.
type PlayerWordCloudResponse struct {
	// AllWordCounts all_word_counts
	AllWordCounts *map[string]interface{} `json:"all_word_counts,omitempty"`

	// MyWordCounts my_word_counts
	MyWordCounts *map[string]interface{} `json:"my_word_counts,omitempty"`
}

// PlayersByRankResponse defines model for PlayersByRankResponse.
type PlayersByRankResponse = []struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// FhUnavailable Indicates if we were unable to fetch full history for this player due to privacy settings
	FhUnavailable *bool `json:"fh_unavailable"`

	// RankTier Integer indicating the rank/medal of the player
	RankTier *float32 `json:"rank_tier,omitempty"`
}

// PlayersResponse defines model for PlayersResponse.
type PlayersResponse struct {
	// CompetitiveRank competitive_rank
	CompetitiveRank *int `json:"competitive_rank"`

	// LeaderboardRank leaderboard_rank
	LeaderboardRank *float32 `json:"leaderboard_rank"`

	// MmrEstimate mmr_estimate
	MmrEstimate *struct {
		// Estimate estimate
		Estimate *float32 `json:"estimate"`
	} `json:"mmr_estimate,omitempty"`

	// Profile profile
	Profile *struct {
		// AccountId The player account ID
		AccountId *int `json:"account_id,omitempty"`

		// Avatar avatar
		Avatar *string `json:"avatar"`

		// Avatarfull avatarfull
		Avatarfull *string `json:"avatarfull"`

		// Avatarmedium avatarmedium
		Avatarmedium *string `json:"avatarmedium"`

		// Cheese cheese
		Cheese *int `json:"cheese"`

		// IsContributor Boolean indicating if the user contributed to the development of OpenDota
		IsContributor *bool `json:"is_contributor,omitempty"`

		// IsSubscriber Boolean indicating if the user subscribed to OpenDota
		IsSubscriber *bool `json:"is_subscriber,omitempty"`

		// LastLogin last_login
		LastLogin *string `json:"last_login"`

		// Loccountrycode loccountrycode
		Loccountrycode *string `json:"loccountrycode"`

		// Name name
		Name *string `json:"name"`

		// Personaname Player's Steam name
		Personaname *string `json:"personaname"`

		// Plus Boolean indicating status of current Dota Plus subscription
		Plus *bool `json:"plus,omitempty"`

		// Profileurl profileurl
		Profileurl *string `json:"profileurl"`

		// Steamid steamid
		Steamid *string `json:"steamid"`
	} `json:"profile,omitempty"`

	// RankTier rank_tier
	RankTier *float32 `json:"rank_tier"`

	// SoloCompetitiveRank solo_competitive_rank
	SoloCompetitiveRank *int `json:"solo_competitive_rank"`
}

// PublicMatchesResponse defines model for PublicMatchesResponse.
type PublicMatchesResponse struct {
	AvgMmr      *int `json:"avg_mmr,omitempty"`
	AvgRankTier *int `json:"avg_rank_tier,omitempty"`
	Cluster     *int `json:"cluster,omitempty"`

	// DireTeam dire_team
	DireTeam *string `json:"dire_team,omitempty"`

	// Duration Duration of the game in seconds
	Duration  *int `json:"duration,omitempty"`
	GameMode  *int `json:"game_mode,omitempty"`
	LobbyType *int `json:"lobby_type,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// MatchSeqNum match_seq_num
	MatchSeqNum *int `json:"match_seq_num,omitempty"`
	NumMmr      *int `json:"num_mmr,omitempty"`
	NumRankTier *int `json:"num_rank_tier,omitempty"`

	// RadiantTeam radiant_team
	RadiantTeam *string `json:"radiant_team,omitempty"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`
}

// RankingsResponse defines model for RankingsResponse.
type RankingsResponse struct {
	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Rankings rankings
	Rankings *[]struct {
		// AccountId The player account ID
		AccountId *int `json:"account_id,omitempty"`

		// Avatar avatar
		Avatar *string `json:"avatar"`

		// Avatarfull avatarfull
		Avatarfull *string `json:"avatarfull"`

		// Avatarmedium avatarmedium
		Avatarmedium *string `json:"avatarmedium"`

		// Cheese cheese
		Cheese *int `json:"cheese"`

		// FhUnavailable fh_unavailable
		FhUnavailable *bool `json:"fh_unavailable"`

		// FullHistoryTime full_history_time
		FullHistoryTime *time.Time `json:"full_history_time,omitempty"`

		// LastLogin last_login
		LastLogin *time.Time `json:"last_login"`

		// Loccountrycode loccountrycode
		Loccountrycode *string `json:"loccountrycode"`

		// Personaname Player's Steam name
		Personaname *string `json:"personaname"`

		// Profileurl profileurl
		Profileurl *string `json:"profileurl"`

		// RankTier rank_tier
		RankTier *int `json:"rank_tier"`

		// Score Score
		Score *float32 `json:"score,omitempty"`

		// Steamid steamid
		Steamid *string `json:"steamid"`
	} `json:"rankings,omitempty"`
}

// RecordsResponse defines model for RecordsResponse.
type RecordsResponse struct {
	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// Score Record score
	Score *int `json:"score,omitempty"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`
}

// ReplaysResponse defines model for ReplaysResponse.
type ReplaysResponse struct {
	// Cluster cluster
	Cluster *int `json:"cluster,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// ReplaySalt replay_salt
	ReplaySalt *int `json:"replay_salt,omitempty"`
}

// ScenarioItemTimingsResponse defines model for ScenarioItemTimingsResponse.
type ScenarioItemTimingsResponse struct {
	// Games The number of games where the hero bought this item before this time
	Games *string `json:"games,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Item Purchased item
	Item *string `json:"item,omitempty"`

	// Time Ingame time in seconds before the item was purchased
	Time *int `json:"time,omitempty"`

	// Wins The number of games won where the hero bought this item before this time
	Wins *string `json:"wins,omitempty"`
}

// ScenarioLaneRolesResponse defines model for ScenarioLaneRolesResponse.
type ScenarioLaneRolesResponse struct {
	// Games The number of games where the hero played in this lane role
	Games *string `json:"games,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// LaneRole The hero's lane role
	LaneRole *int `json:"lane_role,omitempty"`

	// Time Maximum game length in seconds
	Time *int `json:"time,omitempty"`

	// Wins The number of games won where the hero played in this lane role
	Wins *string `json:"wins,omitempty"`
}

// ScenarioMiscResponse defines model for ScenarioMiscResponse.
type ScenarioMiscResponse struct {
	// Games The number of games where this scenario occurred
	Games *string `json:"games,omitempty"`

	// IsRadiant Boolean indicating whether Radiant executed this scenario
	IsRadiant *bool `json:"is_radiant,omitempty"`

	// Region Region the game was played in
	Region *int `json:"region,omitempty"`

	// Scenario The scenario's name or description
	Scenario *string `json:"scenario,omitempty"`

	// Wins The number of games won where this scenario occured
	Wins *string `json:"wins,omitempty"`
}

// SchemaResponse defines model for SchemaResponse.
type SchemaResponse struct {
	// ColumnName column_name
	ColumnName *string `json:"column_name,omitempty"`

	// DataType data_type
	DataType *string `json:"data_type,omitempty"`

	// TableName table_name
	TableName *string `json:"table_name,omitempty"`
}

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// Avatarfull avatarfull
	Avatarfull *string `json:"avatarfull"`

	// LastMatchTime last_match_time. May not be present or null.
	LastMatchTime *string `json:"last_match_time,omitempty"`

	// Personaname Player's Steam name
	Personaname *string `json:"personaname"`

	// Similarity similarity
	Similarity *float32 `json:"similarity,omitempty"`
}

// TeamHeroesResponse defines model for TeamHeroesResponse.
type TeamHeroesResponse struct {
	// GamesPlayed Number of games played
	GamesPlayed *int `json:"games_played,omitempty"`

	// HeroId The ID value of the hero played
	HeroId *int `json:"hero_id,omitempty"`

	// Name Hero name
	Name *string `json:"name,omitempty"`

	// Wins Number of wins
	Wins *int `json:"wins,omitempty"`
}

// TeamMatchObjectResponse defines model for TeamMatchObjectResponse.
type TeamMatchObjectResponse struct {
	// Cluster cluster
	Cluster *int `json:"cluster,omitempty"`

	// DireScore Number of kills the Dire team had when the match ended
	DireScore *int `json:"dire_score,omitempty"`

	// Duration Duration of the game in seconds
	Duration *int `json:"duration,omitempty"`

	// LeagueName Name of league the match took place in
	LeagueName *string `json:"league_name,omitempty"`

	// Leagueid Identifier for the league the match took place in
	Leagueid *int `json:"leagueid,omitempty"`

	// MatchId The ID number of the match assigned by Valve
	MatchId *int `json:"match_id,omitempty"`

	// OpposingTeamId Opposing team identifier
	OpposingTeamId *int `json:"opposing_team_id,omitempty"`

	// OpposingTeamLogo Opposing team logo url
	OpposingTeamLogo *string `json:"opposing_team_logo,omitempty"`

	// OpposingTeamName Opposing team name, e.g. 'Evil Geniuses'
	OpposingTeamName *string `json:"opposing_team_name"`

	// Radiant Whether the team/player/hero was on Radiant
	Radiant *bool `json:"radiant,omitempty"`

	// RadiantScore Number of kills the Radiant team had when the match ended
	RadiantScore *int `json:"radiant_score,omitempty"`

	// RadiantWin Boolean indicating whether Radiant won the match
	RadiantWin *bool `json:"radiant_win"`

	// StartTime The Unix timestamp at which the game started
	StartTime *int `json:"start_time,omitempty"`
}

// TeamObjectResponse defines model for TeamObjectResponse.
type TeamObjectResponse struct {
	// LastMatchTime The Unix timestamp of the last match played by this team
	LastMatchTime *int `json:"last_match_time,omitempty"`

	// Losses The number of losses by this team
	Losses *int `json:"losses,omitempty"`

	// Name Team name
	Name *string `json:"name"`

	// Rating The Elo rating of the team
	Rating *float32 `json:"rating,omitempty"`

	// Tag The team tag/abbreviation
	Tag *string `json:"tag,omitempty"`

	// TeamId Team's identifier
	TeamId *int `json:"team_id,omitempty"`

	// Wins The number of games won by this team
	Wins *int `json:"wins,omitempty"`
}

// TeamPlayersResponse defines model for TeamPlayersResponse.
type TeamPlayersResponse struct {
	// AccountId The player account ID
	AccountId *int `json:"account_id,omitempty"`

	// GamesPlayed Number of games played
	GamesPlayed *int `json:"games_played,omitempty"`

	// IsCurrentTeamMember If this player is on the current roster
	IsCurrentTeamMember *bool `json:"is_current_team_member,omitempty"`

	// Name name
	Name *string `json:"name"`

	// Wins Number of wins
	Wins *int `json:"wins,omitempty"`
}

// AccountIdParam defines model for accountIdParam.
type AccountIdParam = int

// AgainstHeroIdParam defines model for againstHeroIdParam.
type AgainstHeroIdParam = int

// DateParam defines model for dateParam.
type DateParam = int

// ExcludedAccountIdParam defines model for excludedAccountIdParam.
type ExcludedAccountIdParam = int

// FieldParam defines model for fieldParam.
type FieldParam = string

// GameModeParam defines model for gameModeParam.
type GameModeParam = int

// HavingParam defines model for havingParam.
type HavingParam = int

// HeroIdParam defines model for heroIdParam.
type HeroIdParam = int

// HeroIdPathParam defines model for heroIdPathParam.
type HeroIdPathParam = int

// IncludedAccountIdParam defines model for includedAccountIdParam.
type IncludedAccountIdParam = int

// IsRadiantParam defines model for isRadiantParam.
type IsRadiantParam = int

// LaneRoleParam defines model for laneRoleParam.
type LaneRoleParam = int

// LeagueIdPathParam defines model for leagueIdPathParam.
type LeagueIdPathParam = int

// LessThanMatchIdParam defines model for lessThanMatchIdParam.
type LessThanMatchIdParam = int

// LimitParam defines model for limitParam.
type LimitParam = int

// LobbyTypeParam defines model for lobbyTypeParam.
type LobbyTypeParam = int

// MatchIdParam defines model for matchIdParam.
type MatchIdParam = int

// MaxRankParam defines model for maxRankParam.
type MaxRankParam = int

// MinRankParam defines model for minRankParam.
type MinRankParam = int

// MmrAscendingParam defines model for mmrAscendingParam.
type MmrAscendingParam = int

// MmrDescendingParam defines model for mmrDescendingParam.
type MmrDescendingParam = int

// OffsetParam defines model for offsetParam.
type OffsetParam = int

// PatchParam defines model for patchParam.
type PatchParam = int

// ProjectParam defines model for projectParam.
type ProjectParam = string

// RegionParam defines model for regionParam.
type RegionParam = int

// ScenarioParam defines model for scenarioParam.
type ScenarioParam = string

// SignificantParam defines model for significantParam.
type SignificantParam = int

// SortParam defines model for sortParam.
type SortParam = string

// TeamIdPathParam defines model for teamIdPathParam.
type TeamIdPathParam = int

// WinParam defines model for winParam.
type WinParam = int

// WithHeroIdParam defines model for withHeroIdParam.
type WithHeroIdParam = int

// GetBenchmarksParams defines parameters for GetBenchmarks.
type GetBenchmarksParams struct {
	// HeroId Hero ID
	HeroId string `form:"hero_id" json:"hero_id"`
}

// GetExplorerParams defines parameters for GetExplorer.
type GetExplorerParams struct {
	// Sql The PostgreSQL query as percent-encoded string.
	Sql *string `form:"sql,omitempty" json:"sql,omitempty"`
}

// GetFindMatchesParams defines parameters for GetFindMatches.
type GetFindMatchesParams struct {
	// TeamA Hero IDs on first team (array)
	TeamA *[]int `form:"teamA,omitempty" json:"teamA,omitempty"`

	// TeamB Hero IDs on second team (array)
	TeamB *[]int `form:"teamB,omitempty" json:"teamB,omitempty"`
}

// GetParsedMatchesParams defines parameters for GetParsedMatches.
type GetParsedMatchesParams struct {
	// LessThanMatchId Get matches with a match ID lower than this value
	LessThanMatchId *LessThanMatchIdParam `form:"less_than_match_id,omitempty" json:"less_than_match_id,omitempty"`
}

// GetPlayersByAccountIdSelectCountsParams defines parameters for GetPlayersByAccountIdSelectCounts.
type GetPlayersByAccountIdSelectCountsParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectHeroesParams defines parameters for GetPlayersByAccountIdSelectHeroes.
type GetPlayersByAccountIdSelectHeroesParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdHistogramsByFieldParams defines parameters for GetPlayersByAccountIdHistogramsByField.
type GetPlayersByAccountIdHistogramsByFieldParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectMatchesParams defines parameters for GetPlayersByAccountIdSelectMatches.
type GetPlayersByAccountIdSelectMatchesParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Project Fields to project (array)
	Project *ProjectParam `form:"project,omitempty" json:"project,omitempty"`
}

// GetPlayersByAccountIdSelectPeersParams defines parameters for GetPlayersByAccountIdSelectPeers.
type GetPlayersByAccountIdSelectPeersParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectProsParams defines parameters for GetPlayersByAccountIdSelectPros.
type GetPlayersByAccountIdSelectProsParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectTotalsParams defines parameters for GetPlayersByAccountIdSelectTotals.
type GetPlayersByAccountIdSelectTotalsParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectWardmapParams defines parameters for GetPlayersByAccountIdSelectWardmap.
type GetPlayersByAccountIdSelectWardmapParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectWlParams defines parameters for GetPlayersByAccountIdSelectWl.
type GetPlayersByAccountIdSelectWlParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPlayersByAccountIdSelectWordcloudParams defines parameters for GetPlayersByAccountIdSelectWordcloud.
type GetPlayersByAccountIdSelectWordcloudParams struct {
	// Limit Number of matches to limit to
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of matches to offset start by
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Win Whether the player won
	Win *WinParam `form:"win,omitempty" json:"win,omitempty"`

	// Patch Patch ID
	Patch *PatchParam `form:"patch,omitempty" json:"patch,omitempty"`

	// GameMode Game Mode ID
	GameMode *GameModeParam `form:"game_mode,omitempty" json:"game_mode,omitempty"`

	// LobbyType Lobby type ID
	LobbyType *LobbyTypeParam `form:"lobby_type,omitempty" json:"lobby_type,omitempty"`

	// Region Region ID
	Region *RegionParam `form:"region,omitempty" json:"region,omitempty"`

	// Date Days previous
	Date *DateParam `form:"date,omitempty" json:"date,omitempty"`

	// LaneRole Lane Role ID
	LaneRole *LaneRoleParam `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`

	// IsRadiant Whether the player was radiant
	IsRadiant *IsRadiantParam `form:"is_radiant,omitempty" json:"is_radiant,omitempty"`

	// IncludedAccountId Account IDs in the match (array)
	IncludedAccountId *IncludedAccountIdParam `form:"included_account_id,omitempty" json:"included_account_id,omitempty"`

	// ExcludedAccountId Account IDs not in the match (array)
	ExcludedAccountId *ExcludedAccountIdParam `form:"excluded_account_id,omitempty" json:"excluded_account_id,omitempty"`

	// WithHeroId Hero IDs on the player's team (array)
	WithHeroId *WithHeroIdParam `form:"with_hero_id,omitempty" json:"with_hero_id,omitempty"`

	// AgainstHeroId Hero IDs against the player's team (array)
	AgainstHeroId *AgainstHeroIdParam `form:"against_hero_id,omitempty" json:"against_hero_id,omitempty"`

	// Significant Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
	Significant *SignificantParam `form:"significant,omitempty" json:"significant,omitempty"`

	// Having The minimum number of games played, for filtering hero stats
	Having *HavingParam `form:"having,omitempty" json:"having,omitempty"`

	// Sort The field to return matches sorted by in descending order
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetProMatchesParams defines parameters for GetProMatches.
type GetProMatchesParams struct {
	// LessThanMatchId Get matches with a match ID lower than this value
	LessThanMatchId *LessThanMatchIdParam `form:"less_than_match_id,omitempty" json:"less_than_match_id,omitempty"`
}

// GetPublicMatchesParams defines parameters for GetPublicMatches.
type GetPublicMatchesParams struct {
	// LessThanMatchId Get matches with a match ID lower than this value
	LessThanMatchId *LessThanMatchIdParam `form:"less_than_match_id,omitempty" json:"less_than_match_id,omitempty"`

	// MinRank Minimum rank for the matches. Ranks are represented by integers (10-15: Herald, 20-25: Guardian, 30-35: Crusader, 40-45: Archon, 50-55: Legend, 60-65: Ancient, 70-75: Divine, 80-85: Immortal). Each increment represents an additional star.
	MinRank *MinRankParam `form:"min_rank,omitempty" json:"min_rank,omitempty"`

	// MaxRank Maximum rank for the matches. Ranks are represented by integers (10-15: Herald, 20-25: Guardian, 30-35: Crusader, 40-45: Archon, 50-55: Legend, 60-65: Ancient, 70-75: Divine, 80-85: Immortal). Each increment represents an additional star.
	MaxRank *MaxRankParam `form:"max_rank,omitempty" json:"max_rank,omitempty"`

	// MmrAscending Order by MMR ascending
	MmrAscending *MmrAscendingParam `form:"mmr_ascending,omitempty" json:"mmr_ascending,omitempty"`

	// MmrDescending Order by MMR descending
	MmrDescending *MmrDescendingParam `form:"mmr_descending,omitempty" json:"mmr_descending,omitempty"`
}

// GetRankingsParams defines parameters for GetRankings.
type GetRankingsParams struct {
	// HeroId Hero ID
	HeroId string `form:"hero_id" json:"hero_id"`
}

// GetScenariosItemTimingsParams defines parameters for GetScenariosItemTimings.
type GetScenariosItemTimingsParams struct {
	// Item Filter by item name e.g. "spirit_vessel"
	Item *string `form:"item,omitempty" json:"item,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`
}

// GetScenariosLaneRolesParams defines parameters for GetScenariosLaneRoles.
type GetScenariosLaneRolesParams struct {
	// LaneRole Filter by lane role 1-4 (Safe, Mid, Off, Jungle)
	LaneRole *string `form:"lane_role,omitempty" json:"lane_role,omitempty"`

	// HeroId Hero ID
	HeroId *HeroIdParam `form:"hero_id,omitempty" json:"hero_id,omitempty"`
}

// GetScenariosMiscParams defines parameters for GetScenariosMisc.
type GetScenariosMiscParams struct {
	// Scenario pos_chat_1min,neg_chat_1min,courier_kill,first_blood
	Scenario *ScenarioParam `form:"scenario,omitempty" json:"scenario,omitempty"`
}

// GetSearchParams defines parameters for GetSearch.
type GetSearchParams struct {
	// Q Search string
	Q string `form:"q" json:"q"`
}

// GetTeamsParams defines parameters for GetTeams.
type GetTeamsParams struct {
	// Page Page number, zero indexed. Each page returns up to 1000 entries.
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBenchmarks request
	GetBenchmarks(ctx context.Context, params *GetBenchmarksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConstants request
	GetConstants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConstantsByResource request
	GetConstantsByResource(ctx context.Context, resource string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDistributions request
	GetDistributions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExplorer request
	GetExplorer(ctx context.Context, params *GetExplorerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFindMatches request
	GetFindMatches(ctx context.Context, params *GetFindMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHeroStats request
	GetHeroStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHeroes request
	GetHeroes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHeroesByHeroIdSelectDurations request
	GetHeroesByHeroIdSelectDurations(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHeroesByHeroIdSelectItemPopularity request
	GetHeroesByHeroIdSelectItemPopularity(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHeroesByHeroIdSelectMatches request
	GetHeroesByHeroIdSelectMatches(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHeroesByHeroIdSelectMatchups request
	GetHeroesByHeroIdSelectMatchups(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHeroesByHeroIdSelectPlayers request
	GetHeroesByHeroIdSelectPlayers(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeagues request
	GetLeagues(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeaguesByLeagueId request
	GetLeaguesByLeagueId(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeaguesByLeagueIdSelectMatches request
	GetLeaguesByLeagueIdSelectMatches(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeaguesByLeagueIdSelectTeams request
	GetLeaguesByLeagueIdSelectTeams(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLive request
	GetLive(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMatchesByMatchId request
	GetMatchesByMatchId(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetadata request
	GetMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParsedMatches request
	GetParsedMatches(ctx context.Context, params *GetParsedMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountId request
	GetPlayersByAccountId(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectCounts request
	GetPlayersByAccountIdSelectCounts(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectCountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectHeroes request
	GetPlayersByAccountIdSelectHeroes(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectHeroesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdHistogramsByField request
	GetPlayersByAccountIdHistogramsByField(ctx context.Context, accountId AccountIdParam, field FieldParam, params *GetPlayersByAccountIdHistogramsByFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectMatches request
	GetPlayersByAccountIdSelectMatches(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectPeers request
	GetPlayersByAccountIdSelectPeers(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectPeersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectPros request
	GetPlayersByAccountIdSelectPros(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectProsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectRankings request
	GetPlayersByAccountIdSelectRankings(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectRatings request
	GetPlayersByAccountIdSelectRatings(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectRecentMatches request
	GetPlayersByAccountIdSelectRecentMatches(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPlayersAccountIdRefresh request
	PostPlayersAccountIdRefresh(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectTotals request
	GetPlayersByAccountIdSelectTotals(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectTotalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectWardmap request
	GetPlayersByAccountIdSelectWardmap(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWardmapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectWl request
	GetPlayersByAccountIdSelectWl(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByAccountIdSelectWordcloud request
	GetPlayersByAccountIdSelectWordcloud(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWordcloudParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlayersByRank request
	GetPlayersByRank(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProMatches request
	GetProMatches(ctx context.Context, params *GetProMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProPlayers request
	GetProPlayers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicMatches request
	GetPublicMatches(ctx context.Context, params *GetPublicMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRankings request
	GetRankings(ctx context.Context, params *GetRankingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordsByField request
	GetRecordsByField(ctx context.Context, field string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplays request
	GetReplays(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestByJobId request
	GetRequestByJobId(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRequestMatchId request
	PostRequestMatchId(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScenariosItemTimings request
	GetScenariosItemTimings(ctx context.Context, params *GetScenariosItemTimingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScenariosLaneRoles request
	GetScenariosLaneRoles(ctx context.Context, params *GetScenariosLaneRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScenariosMisc request
	GetScenariosMisc(ctx context.Context, params *GetScenariosMiscParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchema request
	GetSchema(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearch request
	GetSearch(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsByTeamId request
	GetTeamsByTeamId(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsByTeamIdSelectHeroes request
	GetTeamsByTeamIdSelectHeroes(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsByTeamIdSelectMatches request
	GetTeamsByTeamIdSelectMatches(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsByTeamIdSelectPlayers request
	GetTeamsByTeamIdSelectPlayers(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBenchmarks(ctx context.Context, params *GetBenchmarksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenchmarksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConstants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConstantsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConstantsByResource(ctx context.Context, resource string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConstantsByResourceRequest(c.Server, resource)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDistributions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDistributionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExplorer(ctx context.Context, params *GetExplorerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExplorerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFindMatches(ctx context.Context, params *GetFindMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFindMatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHeroStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHeroStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHeroes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHeroesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHeroesByHeroIdSelectDurations(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHeroesByHeroIdSelectDurationsRequest(c.Server, heroId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHeroesByHeroIdSelectItemPopularity(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHeroesByHeroIdSelectItemPopularityRequest(c.Server, heroId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHeroesByHeroIdSelectMatches(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHeroesByHeroIdSelectMatchesRequest(c.Server, heroId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHeroesByHeroIdSelectMatchups(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHeroesByHeroIdSelectMatchupsRequest(c.Server, heroId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHeroesByHeroIdSelectPlayers(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHeroesByHeroIdSelectPlayersRequest(c.Server, heroId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeagues(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaguesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeaguesByLeagueId(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaguesByLeagueIdRequest(c.Server, leagueId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeaguesByLeagueIdSelectMatches(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaguesByLeagueIdSelectMatchesRequest(c.Server, leagueId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeaguesByLeagueIdSelectTeams(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaguesByLeagueIdSelectTeamsRequest(c.Server, leagueId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLive(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMatchesByMatchId(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMatchesByMatchIdRequest(c.Server, matchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetadataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParsedMatches(ctx context.Context, params *GetParsedMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParsedMatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountId(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectCounts(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectCountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectCountsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectHeroes(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectHeroesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectHeroesRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdHistogramsByField(ctx context.Context, accountId AccountIdParam, field FieldParam, params *GetPlayersByAccountIdHistogramsByFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdHistogramsByFieldRequest(c.Server, accountId, field, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectMatches(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectMatchesRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectPeers(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectPeersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectPeersRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectPros(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectProsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectProsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectRankings(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectRankingsRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectRatings(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectRatingsRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectRecentMatches(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectRecentMatchesRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPlayersAccountIdRefresh(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPlayersAccountIdRefreshRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectTotals(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectTotalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectTotalsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectWardmap(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWardmapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectWardmapRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectWl(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectWlRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByAccountIdSelectWordcloud(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWordcloudParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByAccountIdSelectWordcloudRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlayersByRank(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlayersByRankRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProMatches(ctx context.Context, params *GetProMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProMatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProPlayers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProPlayersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicMatches(ctx context.Context, params *GetPublicMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicMatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRankings(ctx context.Context, params *GetRankingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRankingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordsByField(ctx context.Context, field string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordsByFieldRequest(c.Server, field)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplays(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplaysRequest(c.Server, matchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestByJobId(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestByJobIdRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRequestMatchId(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRequestMatchIdRequest(c.Server, matchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScenariosItemTimings(ctx context.Context, params *GetScenariosItemTimingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScenariosItemTimingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScenariosLaneRoles(ctx context.Context, params *GetScenariosLaneRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScenariosLaneRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScenariosMisc(ctx context.Context, params *GetScenariosMiscParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScenariosMiscRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchema(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearch(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsByTeamId(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsByTeamIdRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsByTeamIdSelectHeroes(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsByTeamIdSelectHeroesRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsByTeamIdSelectMatches(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsByTeamIdSelectMatchesRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsByTeamIdSelectPlayers(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsByTeamIdSelectPlayersRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBenchmarksRequest generates requests for GetBenchmarks
func NewGetBenchmarksRequest(server string, params *GetBenchmarksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benchmarks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, params.HeroId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConstantsRequest generates requests for GetConstants
func NewGetConstantsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/constants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConstantsByResourceRequest generates requests for GetConstantsByResource
func NewGetConstantsByResourceRequest(server string, resource string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resource", runtime.ParamLocationPath, resource)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/constants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDistributionsRequest generates requests for GetDistributions
func NewGetDistributionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/distributions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExplorerRequest generates requests for GetExplorer
func NewGetExplorerRequest(server string, params *GetExplorerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/explorer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sql != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sql", runtime.ParamLocationQuery, *params.Sql); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFindMatchesRequest generates requests for GetFindMatches
func NewGetFindMatchesRequest(server string, params *GetFindMatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/findMatches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamA != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "teamA", runtime.ParamLocationQuery, *params.TeamA); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamB != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "teamB", runtime.ParamLocationQuery, *params.TeamB); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHeroStatsRequest generates requests for GetHeroStats
func NewGetHeroStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/heroStats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHeroesRequest generates requests for GetHeroes
func NewGetHeroesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/heroes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHeroesByHeroIdSelectDurationsRequest generates requests for GetHeroesByHeroIdSelectDurations
func NewGetHeroesByHeroIdSelectDurationsRequest(server string, heroId HeroIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hero_id", runtime.ParamLocationPath, heroId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/heroes/%s/durations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHeroesByHeroIdSelectItemPopularityRequest generates requests for GetHeroesByHeroIdSelectItemPopularity
func NewGetHeroesByHeroIdSelectItemPopularityRequest(server string, heroId HeroIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hero_id", runtime.ParamLocationPath, heroId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/heroes/%s/itemPopularity", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHeroesByHeroIdSelectMatchesRequest generates requests for GetHeroesByHeroIdSelectMatches
func NewGetHeroesByHeroIdSelectMatchesRequest(server string, heroId HeroIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hero_id", runtime.ParamLocationPath, heroId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/heroes/%s/matches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHeroesByHeroIdSelectMatchupsRequest generates requests for GetHeroesByHeroIdSelectMatchups
func NewGetHeroesByHeroIdSelectMatchupsRequest(server string, heroId HeroIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hero_id", runtime.ParamLocationPath, heroId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/heroes/%s/matchups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHeroesByHeroIdSelectPlayersRequest generates requests for GetHeroesByHeroIdSelectPlayers
func NewGetHeroesByHeroIdSelectPlayersRequest(server string, heroId HeroIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hero_id", runtime.ParamLocationPath, heroId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/heroes/%s/players", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeaguesRequest generates requests for GetLeagues
func NewGetLeaguesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leagues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeaguesByLeagueIdRequest generates requests for GetLeaguesByLeagueId
func NewGetLeaguesByLeagueIdRequest(server string, leagueId LeagueIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "league_id", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leagues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeaguesByLeagueIdSelectMatchesRequest generates requests for GetLeaguesByLeagueIdSelectMatches
func NewGetLeaguesByLeagueIdSelectMatchesRequest(server string, leagueId LeagueIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "league_id", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leagues/%s/matches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeaguesByLeagueIdSelectTeamsRequest generates requests for GetLeaguesByLeagueIdSelectTeams
func NewGetLeaguesByLeagueIdSelectTeamsRequest(server string, leagueId LeagueIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "league_id", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leagues/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLiveRequest generates requests for GetLive
func NewGetLiveRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMatchesByMatchIdRequest generates requests for GetMatchesByMatchId
func NewGetMatchesByMatchIdRequest(server string, matchId MatchIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "match_id", runtime.ParamLocationPath, matchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/matches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetadataRequest generates requests for GetMetadata
func NewGetMetadataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetParsedMatchesRequest generates requests for GetParsedMatches
func NewGetParsedMatchesRequest(server string, params *GetParsedMatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parsedMatches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LessThanMatchId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "less_than_match_id", runtime.ParamLocationQuery, *params.LessThanMatchId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdRequest generates requests for GetPlayersByAccountId
func NewGetPlayersByAccountIdRequest(server string, accountId AccountIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectCountsRequest generates requests for GetPlayersByAccountIdSelectCounts
func NewGetPlayersByAccountIdSelectCountsRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectCountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/counts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectHeroesRequest generates requests for GetPlayersByAccountIdSelectHeroes
func NewGetPlayersByAccountIdSelectHeroesRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectHeroesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/heroes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdHistogramsByFieldRequest generates requests for GetPlayersByAccountIdHistogramsByField
func NewGetPlayersByAccountIdHistogramsByFieldRequest(server string, accountId AccountIdParam, field FieldParam, params *GetPlayersByAccountIdHistogramsByFieldParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "field", runtime.ParamLocationPath, field)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/histograms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectMatchesRequest generates requests for GetPlayersByAccountIdSelectMatches
func NewGetPlayersByAccountIdSelectMatchesRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectMatchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/matches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Project != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project", runtime.ParamLocationQuery, *params.Project); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectPeersRequest generates requests for GetPlayersByAccountIdSelectPeers
func NewGetPlayersByAccountIdSelectPeersRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectPeersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/peers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectProsRequest generates requests for GetPlayersByAccountIdSelectPros
func NewGetPlayersByAccountIdSelectProsRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectProsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/pros", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectRankingsRequest generates requests for GetPlayersByAccountIdSelectRankings
func NewGetPlayersByAccountIdSelectRankingsRequest(server string, accountId AccountIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/rankings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectRatingsRequest generates requests for GetPlayersByAccountIdSelectRatings
func NewGetPlayersByAccountIdSelectRatingsRequest(server string, accountId AccountIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/ratings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectRecentMatchesRequest generates requests for GetPlayersByAccountIdSelectRecentMatches
func NewGetPlayersByAccountIdSelectRecentMatchesRequest(server string, accountId AccountIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/recentMatches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPlayersAccountIdRefreshRequest generates requests for PostPlayersAccountIdRefresh
func NewPostPlayersAccountIdRefreshRequest(server string, accountId AccountIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/refresh", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectTotalsRequest generates requests for GetPlayersByAccountIdSelectTotals
func NewGetPlayersByAccountIdSelectTotalsRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectTotalsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/totals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectWardmapRequest generates requests for GetPlayersByAccountIdSelectWardmap
func NewGetPlayersByAccountIdSelectWardmapRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWardmapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/wardmap", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectWlRequest generates requests for GetPlayersByAccountIdSelectWl
func NewGetPlayersByAccountIdSelectWlRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/wl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByAccountIdSelectWordcloudRequest generates requests for GetPlayersByAccountIdSelectWordcloud
func NewGetPlayersByAccountIdSelectWordcloudRequest(server string, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWordcloudParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/players/%s/wordcloud", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Win != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "win", runtime.ParamLocationQuery, *params.Win); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Patch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "patch", runtime.ParamLocationQuery, *params.Patch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_mode", runtime.ParamLocationQuery, *params.GameMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LobbyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lobby_type", runtime.ParamLocationQuery, *params.LobbyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsRadiant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_radiant", runtime.ParamLocationQuery, *params.IsRadiant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_account_id", runtime.ParamLocationQuery, *params.IncludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedAccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_account_id", runtime.ParamLocationQuery, *params.ExcludedAccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hero_id", runtime.ParamLocationQuery, *params.WithHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgainstHeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "against_hero_id", runtime.ParamLocationQuery, *params.AgainstHeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Significant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "significant", runtime.ParamLocationQuery, *params.Significant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Having != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "having", runtime.ParamLocationQuery, *params.Having); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlayersByRankRequest generates requests for GetPlayersByRank
func NewGetPlayersByRankRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playersByRank")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProMatchesRequest generates requests for GetProMatches
func NewGetProMatchesRequest(server string, params *GetProMatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proMatches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LessThanMatchId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "less_than_match_id", runtime.ParamLocationQuery, *params.LessThanMatchId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProPlayersRequest generates requests for GetProPlayers
func NewGetProPlayersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proPlayers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicMatchesRequest generates requests for GetPublicMatches
func NewGetPublicMatchesRequest(server string, params *GetPublicMatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicMatches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LessThanMatchId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "less_than_match_id", runtime.ParamLocationQuery, *params.LessThanMatchId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinRank != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_rank", runtime.ParamLocationQuery, *params.MinRank); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRank != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_rank", runtime.ParamLocationQuery, *params.MaxRank); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MmrAscending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mmr_ascending", runtime.ParamLocationQuery, *params.MmrAscending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MmrDescending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mmr_descending", runtime.ParamLocationQuery, *params.MmrDescending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRankingsRequest generates requests for GetRankings
func NewGetRankingsRequest(server string, params *GetRankingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rankings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, params.HeroId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordsByFieldRequest generates requests for GetRecordsByField
func NewGetRecordsByFieldRequest(server string, field string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field", runtime.ParamLocationPath, field)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/records/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReplaysRequest generates requests for GetReplays
func NewGetReplaysRequest(server string, matchId MatchIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "match_id", runtime.ParamLocationPath, matchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/replays/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequestByJobIdRequest generates requests for GetRequestByJobId
func NewGetRequestByJobIdRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRequestMatchIdRequest generates requests for PostRequestMatchId
func NewPostRequestMatchIdRequest(server string, matchId MatchIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "match_id", runtime.ParamLocationPath, matchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScenariosItemTimingsRequest generates requests for GetScenariosItemTimings
func NewGetScenariosItemTimingsRequest(server string, params *GetScenariosItemTimingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scenarios/itemTimings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Item != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "item", runtime.ParamLocationQuery, *params.Item); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScenariosLaneRolesRequest generates requests for GetScenariosLaneRoles
func NewGetScenariosLaneRolesRequest(server string, params *GetScenariosLaneRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scenarios/laneRoles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LaneRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lane_role", runtime.ParamLocationQuery, *params.LaneRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HeroId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hero_id", runtime.ParamLocationQuery, *params.HeroId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScenariosMiscRequest generates requests for GetScenariosMisc
func NewGetScenariosMiscRequest(server string, params *GetScenariosMiscParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scenarios/misc")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Scenario != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scenario", runtime.ParamLocationQuery, *params.Scenario); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemaRequest generates requests for GetSchema
func NewGetSchemaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schema")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchRequest generates requests for GetSearch
func NewGetSearchRequest(server string, params *GetSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsByTeamIdRequest generates requests for GetTeamsByTeamId
func NewGetTeamsByTeamIdRequest(server string, teamId TeamIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsByTeamIdSelectHeroesRequest generates requests for GetTeamsByTeamIdSelectHeroes
func NewGetTeamsByTeamIdSelectHeroesRequest(server string, teamId TeamIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/heroes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsByTeamIdSelectMatchesRequest generates requests for GetTeamsByTeamIdSelectMatches
func NewGetTeamsByTeamIdSelectMatchesRequest(server string, teamId TeamIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/matches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsByTeamIdSelectPlayersRequest generates requests for GetTeamsByTeamIdSelectPlayers
func NewGetTeamsByTeamIdSelectPlayersRequest(server string, teamId TeamIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/players", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBenchmarksWithResponse request
	GetBenchmarksWithResponse(ctx context.Context, params *GetBenchmarksParams, reqEditors ...RequestEditorFn) (*GetBenchmarksResponse, error)

	// GetConstantsWithResponse request
	GetConstantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConstantsResponse, error)

	// GetConstantsByResourceWithResponse request
	GetConstantsByResourceWithResponse(ctx context.Context, resource string, reqEditors ...RequestEditorFn) (*GetConstantsByResourceResponse, error)

	// GetDistributionsWithResponse request
	GetDistributionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDistributionsResponse, error)

	// GetExplorerWithResponse request
	GetExplorerWithResponse(ctx context.Context, params *GetExplorerParams, reqEditors ...RequestEditorFn) (*GetExplorerResponse, error)

	// GetFindMatchesWithResponse request
	GetFindMatchesWithResponse(ctx context.Context, params *GetFindMatchesParams, reqEditors ...RequestEditorFn) (*GetFindMatchesResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetHeroStatsWithResponse request
	GetHeroStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHeroStatsResponse, error)

	// GetHeroesWithResponse request
	GetHeroesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHeroesResponse, error)

	// GetHeroesByHeroIdSelectDurationsWithResponse request
	GetHeroesByHeroIdSelectDurationsWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectDurationsResponse, error)

	// GetHeroesByHeroIdSelectItemPopularityWithResponse request
	GetHeroesByHeroIdSelectItemPopularityWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectItemPopularityResponse, error)

	// GetHeroesByHeroIdSelectMatchesWithResponse request
	GetHeroesByHeroIdSelectMatchesWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectMatchesResponse, error)

	// GetHeroesByHeroIdSelectMatchupsWithResponse request
	GetHeroesByHeroIdSelectMatchupsWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectMatchupsResponse, error)

	// GetHeroesByHeroIdSelectPlayersWithResponse request
	GetHeroesByHeroIdSelectPlayersWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectPlayersResponse, error)

	// GetLeaguesWithResponse request
	GetLeaguesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeaguesResponse, error)

	// GetLeaguesByLeagueIdWithResponse request
	GetLeaguesByLeagueIdWithResponse(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*GetLeaguesByLeagueIdResponse, error)

	// GetLeaguesByLeagueIdSelectMatchesWithResponse request
	GetLeaguesByLeagueIdSelectMatchesWithResponse(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*GetLeaguesByLeagueIdSelectMatchesResponse, error)

	// GetLeaguesByLeagueIdSelectTeamsWithResponse request
	GetLeaguesByLeagueIdSelectTeamsWithResponse(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*GetLeaguesByLeagueIdSelectTeamsResponse, error)

	// GetLiveWithResponse request
	GetLiveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLiveResponse, error)

	// GetMatchesByMatchIdWithResponse request
	GetMatchesByMatchIdWithResponse(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*GetMatchesByMatchIdResponse, error)

	// GetMetadataWithResponse request
	GetMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetadataResponse, error)

	// GetParsedMatchesWithResponse request
	GetParsedMatchesWithResponse(ctx context.Context, params *GetParsedMatchesParams, reqEditors ...RequestEditorFn) (*GetParsedMatchesResponse, error)

	// GetPlayersByAccountIdWithResponse request
	GetPlayersByAccountIdWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdResponse, error)

	// GetPlayersByAccountIdSelectCountsWithResponse request
	GetPlayersByAccountIdSelectCountsWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectCountsParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectCountsResponse, error)

	// GetPlayersByAccountIdSelectHeroesWithResponse request
	GetPlayersByAccountIdSelectHeroesWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectHeroesParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectHeroesResponse, error)

	// GetPlayersByAccountIdHistogramsByFieldWithResponse request
	GetPlayersByAccountIdHistogramsByFieldWithResponse(ctx context.Context, accountId AccountIdParam, field FieldParam, params *GetPlayersByAccountIdHistogramsByFieldParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdHistogramsByFieldResponse, error)

	// GetPlayersByAccountIdSelectMatchesWithResponse request
	GetPlayersByAccountIdSelectMatchesWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectMatchesParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectMatchesResponse, error)

	// GetPlayersByAccountIdSelectPeersWithResponse request
	GetPlayersByAccountIdSelectPeersWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectPeersParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectPeersResponse, error)

	// GetPlayersByAccountIdSelectProsWithResponse request
	GetPlayersByAccountIdSelectProsWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectProsParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectProsResponse, error)

	// GetPlayersByAccountIdSelectRankingsWithResponse request
	GetPlayersByAccountIdSelectRankingsWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectRankingsResponse, error)

	// GetPlayersByAccountIdSelectRatingsWithResponse request
	GetPlayersByAccountIdSelectRatingsWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectRatingsResponse, error)

	// GetPlayersByAccountIdSelectRecentMatchesWithResponse request
	GetPlayersByAccountIdSelectRecentMatchesWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectRecentMatchesResponse, error)

	// PostPlayersAccountIdRefreshWithResponse request
	PostPlayersAccountIdRefreshWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*PostPlayersAccountIdRefreshResponse, error)

	// GetPlayersByAccountIdSelectTotalsWithResponse request
	GetPlayersByAccountIdSelectTotalsWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectTotalsParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectTotalsResponse, error)

	// GetPlayersByAccountIdSelectWardmapWithResponse request
	GetPlayersByAccountIdSelectWardmapWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWardmapParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectWardmapResponse, error)

	// GetPlayersByAccountIdSelectWlWithResponse request
	GetPlayersByAccountIdSelectWlWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWlParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectWlResponse, error)

	// GetPlayersByAccountIdSelectWordcloudWithResponse request
	GetPlayersByAccountIdSelectWordcloudWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWordcloudParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectWordcloudResponse, error)

	// GetPlayersByRankWithResponse request
	GetPlayersByRankWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPlayersByRankResponse, error)

	// GetProMatchesWithResponse request
	GetProMatchesWithResponse(ctx context.Context, params *GetProMatchesParams, reqEditors ...RequestEditorFn) (*GetProMatchesResponse, error)

	// GetProPlayersWithResponse request
	GetProPlayersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProPlayersResponse, error)

	// GetPublicMatchesWithResponse request
	GetPublicMatchesWithResponse(ctx context.Context, params *GetPublicMatchesParams, reqEditors ...RequestEditorFn) (*GetPublicMatchesResponse, error)

	// GetRankingsWithResponse request
	GetRankingsWithResponse(ctx context.Context, params *GetRankingsParams, reqEditors ...RequestEditorFn) (*GetRankingsResponse, error)

	// GetRecordsByFieldWithResponse request
	GetRecordsByFieldWithResponse(ctx context.Context, field string, reqEditors ...RequestEditorFn) (*GetRecordsByFieldResponse, error)

	// GetReplaysWithResponse request
	GetReplaysWithResponse(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*GetReplaysResponse, error)

	// GetRequestByJobIdWithResponse request
	GetRequestByJobIdWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetRequestByJobIdResponse, error)

	// PostRequestMatchIdWithResponse request
	PostRequestMatchIdWithResponse(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*PostRequestMatchIdResponse, error)

	// GetScenariosItemTimingsWithResponse request
	GetScenariosItemTimingsWithResponse(ctx context.Context, params *GetScenariosItemTimingsParams, reqEditors ...RequestEditorFn) (*GetScenariosItemTimingsResponse, error)

	// GetScenariosLaneRolesWithResponse request
	GetScenariosLaneRolesWithResponse(ctx context.Context, params *GetScenariosLaneRolesParams, reqEditors ...RequestEditorFn) (*GetScenariosLaneRolesResponse, error)

	// GetScenariosMiscWithResponse request
	GetScenariosMiscWithResponse(ctx context.Context, params *GetScenariosMiscParams, reqEditors ...RequestEditorFn) (*GetScenariosMiscResponse, error)

	// GetSchemaWithResponse request
	GetSchemaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSchemaResponse, error)

	// GetSearchWithResponse request
	GetSearchWithResponse(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*GetSearchResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)

	// GetTeamsWithResponse request
	GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error)

	// GetTeamsByTeamIdWithResponse request
	GetTeamsByTeamIdWithResponse(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*GetTeamsByTeamIdResponse, error)

	// GetTeamsByTeamIdSelectHeroesWithResponse request
	GetTeamsByTeamIdSelectHeroesWithResponse(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*GetTeamsByTeamIdSelectHeroesResponse, error)

	// GetTeamsByTeamIdSelectMatchesWithResponse request
	GetTeamsByTeamIdSelectMatchesWithResponse(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*GetTeamsByTeamIdSelectMatchesResponse, error)

	// GetTeamsByTeamIdSelectPlayersWithResponse request
	GetTeamsByTeamIdSelectPlayersWithResponse(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*GetTeamsByTeamIdSelectPlayersResponse, error)
}

type GetBenchmarksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBenchmarksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenchmarksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConstantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetConstantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConstantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConstantsByResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetConstantsByResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConstantsByResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDistributionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDistributionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDistributionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExplorerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetExplorerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExplorerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFindMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFindMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFindMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHeroStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHeroStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHeroStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHeroesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHeroesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHeroesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHeroesByHeroIdSelectDurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHeroesByHeroIdSelectDurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHeroesByHeroIdSelectDurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHeroesByHeroIdSelectItemPopularityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHeroesByHeroIdSelectItemPopularityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHeroesByHeroIdSelectItemPopularityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHeroesByHeroIdSelectMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHeroesByHeroIdSelectMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHeroesByHeroIdSelectMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHeroesByHeroIdSelectMatchupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHeroesByHeroIdSelectMatchupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHeroesByHeroIdSelectMatchupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHeroesByHeroIdSelectPlayersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHeroesByHeroIdSelectPlayersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHeroesByHeroIdSelectPlayersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaguesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLeaguesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaguesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaguesByLeagueIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLeaguesByLeagueIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaguesByLeagueIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaguesByLeagueIdSelectMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLeaguesByLeagueIdSelectMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaguesByLeagueIdSelectMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaguesByLeagueIdSelectTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLeaguesByLeagueIdSelectTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaguesByLeagueIdSelectTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMatchesByMatchIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMatchesByMatchIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMatchesByMatchIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParsedMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetParsedMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParsedMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectCountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectCountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectCountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectHeroesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectHeroesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectHeroesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdHistogramsByFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdHistogramsByFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdHistogramsByFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectPeersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectPeersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectPeersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectProsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectProsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectProsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectRankingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectRankingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectRankingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectRatingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectRatingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectRatingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectRecentMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectRecentMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectRecentMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPlayersAccountIdRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostPlayersAccountIdRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPlayersAccountIdRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectTotalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectTotalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectTotalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectWardmapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectWardmapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectWardmapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectWlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectWlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectWlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByAccountIdSelectWordcloudResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByAccountIdSelectWordcloudResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByAccountIdSelectWordcloudResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlayersByRankResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPlayersByRankResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlayersByRankResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProPlayersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProPlayersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProPlayersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPublicMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRankingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRankingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRankingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordsByFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRecordsByFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordsByFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReplaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestByJobIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRequestByJobIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestByJobIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRequestMatchIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostRequestMatchIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRequestMatchIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScenariosItemTimingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetScenariosItemTimingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScenariosItemTimingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScenariosLaneRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetScenariosLaneRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScenariosLaneRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScenariosMiscResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetScenariosMiscResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScenariosMiscResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsByTeamIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeamsByTeamIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsByTeamIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsByTeamIdSelectHeroesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeamsByTeamIdSelectHeroesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsByTeamIdSelectHeroesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsByTeamIdSelectMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeamsByTeamIdSelectMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsByTeamIdSelectMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsByTeamIdSelectPlayersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeamsByTeamIdSelectPlayersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsByTeamIdSelectPlayersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBenchmarksWithResponse request returning *GetBenchmarksResponse
func (c *ClientWithResponses) GetBenchmarksWithResponse(ctx context.Context, params *GetBenchmarksParams, reqEditors ...RequestEditorFn) (*GetBenchmarksResponse, error) {
	rsp, err := c.GetBenchmarks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenchmarksResponse(rsp)
}

// GetConstantsWithResponse request returning *GetConstantsResponse
func (c *ClientWithResponses) GetConstantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConstantsResponse, error) {
	rsp, err := c.GetConstants(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConstantsResponse(rsp)
}

// GetConstantsByResourceWithResponse request returning *GetConstantsByResourceResponse
func (c *ClientWithResponses) GetConstantsByResourceWithResponse(ctx context.Context, resource string, reqEditors ...RequestEditorFn) (*GetConstantsByResourceResponse, error) {
	rsp, err := c.GetConstantsByResource(ctx, resource, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConstantsByResourceResponse(rsp)
}

// GetDistributionsWithResponse request returning *GetDistributionsResponse
func (c *ClientWithResponses) GetDistributionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDistributionsResponse, error) {
	rsp, err := c.GetDistributions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDistributionsResponse(rsp)
}

// GetExplorerWithResponse request returning *GetExplorerResponse
func (c *ClientWithResponses) GetExplorerWithResponse(ctx context.Context, params *GetExplorerParams, reqEditors ...RequestEditorFn) (*GetExplorerResponse, error) {
	rsp, err := c.GetExplorer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExplorerResponse(rsp)
}

// GetFindMatchesWithResponse request returning *GetFindMatchesResponse
func (c *ClientWithResponses) GetFindMatchesWithResponse(ctx context.Context, params *GetFindMatchesParams, reqEditors ...RequestEditorFn) (*GetFindMatchesResponse, error) {
	rsp, err := c.GetFindMatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFindMatchesResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetHeroStatsWithResponse request returning *GetHeroStatsResponse
func (c *ClientWithResponses) GetHeroStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHeroStatsResponse, error) {
	rsp, err := c.GetHeroStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHeroStatsResponse(rsp)
}

// GetHeroesWithResponse request returning *GetHeroesResponse
func (c *ClientWithResponses) GetHeroesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHeroesResponse, error) {
	rsp, err := c.GetHeroes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHeroesResponse(rsp)
}

// GetHeroesByHeroIdSelectDurationsWithResponse request returning *GetHeroesByHeroIdSelectDurationsResponse
func (c *ClientWithResponses) GetHeroesByHeroIdSelectDurationsWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectDurationsResponse, error) {
	rsp, err := c.GetHeroesByHeroIdSelectDurations(ctx, heroId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHeroesByHeroIdSelectDurationsResponse(rsp)
}

// GetHeroesByHeroIdSelectItemPopularityWithResponse request returning *GetHeroesByHeroIdSelectItemPopularityResponse
func (c *ClientWithResponses) GetHeroesByHeroIdSelectItemPopularityWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectItemPopularityResponse, error) {
	rsp, err := c.GetHeroesByHeroIdSelectItemPopularity(ctx, heroId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHeroesByHeroIdSelectItemPopularityResponse(rsp)
}

// GetHeroesByHeroIdSelectMatchesWithResponse request returning *GetHeroesByHeroIdSelectMatchesResponse
func (c *ClientWithResponses) GetHeroesByHeroIdSelectMatchesWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectMatchesResponse, error) {
	rsp, err := c.GetHeroesByHeroIdSelectMatches(ctx, heroId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHeroesByHeroIdSelectMatchesResponse(rsp)
}

// GetHeroesByHeroIdSelectMatchupsWithResponse request returning *GetHeroesByHeroIdSelectMatchupsResponse
func (c *ClientWithResponses) GetHeroesByHeroIdSelectMatchupsWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectMatchupsResponse, error) {
	rsp, err := c.GetHeroesByHeroIdSelectMatchups(ctx, heroId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHeroesByHeroIdSelectMatchupsResponse(rsp)
}

// GetHeroesByHeroIdSelectPlayersWithResponse request returning *GetHeroesByHeroIdSelectPlayersResponse
func (c *ClientWithResponses) GetHeroesByHeroIdSelectPlayersWithResponse(ctx context.Context, heroId HeroIdPathParam, reqEditors ...RequestEditorFn) (*GetHeroesByHeroIdSelectPlayersResponse, error) {
	rsp, err := c.GetHeroesByHeroIdSelectPlayers(ctx, heroId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHeroesByHeroIdSelectPlayersResponse(rsp)
}

// GetLeaguesWithResponse request returning *GetLeaguesResponse
func (c *ClientWithResponses) GetLeaguesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeaguesResponse, error) {
	rsp, err := c.GetLeagues(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaguesResponse(rsp)
}

// GetLeaguesByLeagueIdWithResponse request returning *GetLeaguesByLeagueIdResponse
func (c *ClientWithResponses) GetLeaguesByLeagueIdWithResponse(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*GetLeaguesByLeagueIdResponse, error) {
	rsp, err := c.GetLeaguesByLeagueId(ctx, leagueId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaguesByLeagueIdResponse(rsp)
}

// GetLeaguesByLeagueIdSelectMatchesWithResponse request returning *GetLeaguesByLeagueIdSelectMatchesResponse
func (c *ClientWithResponses) GetLeaguesByLeagueIdSelectMatchesWithResponse(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*GetLeaguesByLeagueIdSelectMatchesResponse, error) {
	rsp, err := c.GetLeaguesByLeagueIdSelectMatches(ctx, leagueId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaguesByLeagueIdSelectMatchesResponse(rsp)
}

// GetLeaguesByLeagueIdSelectTeamsWithResponse request returning *GetLeaguesByLeagueIdSelectTeamsResponse
func (c *ClientWithResponses) GetLeaguesByLeagueIdSelectTeamsWithResponse(ctx context.Context, leagueId LeagueIdPathParam, reqEditors ...RequestEditorFn) (*GetLeaguesByLeagueIdSelectTeamsResponse, error) {
	rsp, err := c.GetLeaguesByLeagueIdSelectTeams(ctx, leagueId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaguesByLeagueIdSelectTeamsResponse(rsp)
}

// GetLiveWithResponse request returning *GetLiveResponse
func (c *ClientWithResponses) GetLiveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLiveResponse, error) {
	rsp, err := c.GetLive(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveResponse(rsp)
}

// GetMatchesByMatchIdWithResponse request returning *GetMatchesByMatchIdResponse
func (c *ClientWithResponses) GetMatchesByMatchIdWithResponse(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*GetMatchesByMatchIdResponse, error) {
	rsp, err := c.GetMatchesByMatchId(ctx, matchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMatchesByMatchIdResponse(rsp)
}

// GetMetadataWithResponse request returning *GetMetadataResponse
func (c *ClientWithResponses) GetMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetadataResponse, error) {
	rsp, err := c.GetMetadata(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetadataResponse(rsp)
}

// GetParsedMatchesWithResponse request returning *GetParsedMatchesResponse
func (c *ClientWithResponses) GetParsedMatchesWithResponse(ctx context.Context, params *GetParsedMatchesParams, reqEditors ...RequestEditorFn) (*GetParsedMatchesResponse, error) {
	rsp, err := c.GetParsedMatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParsedMatchesResponse(rsp)
}

// GetPlayersByAccountIdWithResponse request returning *GetPlayersByAccountIdResponse
func (c *ClientWithResponses) GetPlayersByAccountIdWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdResponse, error) {
	rsp, err := c.GetPlayersByAccountId(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdResponse(rsp)
}

// GetPlayersByAccountIdSelectCountsWithResponse request returning *GetPlayersByAccountIdSelectCountsResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectCountsWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectCountsParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectCountsResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectCounts(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectCountsResponse(rsp)
}

// GetPlayersByAccountIdSelectHeroesWithResponse request returning *GetPlayersByAccountIdSelectHeroesResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectHeroesWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectHeroesParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectHeroesResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectHeroes(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectHeroesResponse(rsp)
}

// GetPlayersByAccountIdHistogramsByFieldWithResponse request returning *GetPlayersByAccountIdHistogramsByFieldResponse
func (c *ClientWithResponses) GetPlayersByAccountIdHistogramsByFieldWithResponse(ctx context.Context, accountId AccountIdParam, field FieldParam, params *GetPlayersByAccountIdHistogramsByFieldParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdHistogramsByFieldResponse, error) {
	rsp, err := c.GetPlayersByAccountIdHistogramsByField(ctx, accountId, field, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdHistogramsByFieldResponse(rsp)
}

// GetPlayersByAccountIdSelectMatchesWithResponse request returning *GetPlayersByAccountIdSelectMatchesResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectMatchesWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectMatchesParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectMatchesResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectMatches(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectMatchesResponse(rsp)
}

// GetPlayersByAccountIdSelectPeersWithResponse request returning *GetPlayersByAccountIdSelectPeersResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectPeersWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectPeersParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectPeersResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectPeers(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectPeersResponse(rsp)
}

// GetPlayersByAccountIdSelectProsWithResponse request returning *GetPlayersByAccountIdSelectProsResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectProsWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectProsParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectProsResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectPros(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectProsResponse(rsp)
}

// GetPlayersByAccountIdSelectRankingsWithResponse request returning *GetPlayersByAccountIdSelectRankingsResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectRankingsWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectRankingsResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectRankings(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectRankingsResponse(rsp)
}

// GetPlayersByAccountIdSelectRatingsWithResponse request returning *GetPlayersByAccountIdSelectRatingsResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectRatingsWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectRatingsResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectRatings(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectRatingsResponse(rsp)
}

// GetPlayersByAccountIdSelectRecentMatchesWithResponse request returning *GetPlayersByAccountIdSelectRecentMatchesResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectRecentMatchesWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectRecentMatchesResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectRecentMatches(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectRecentMatchesResponse(rsp)
}

// PostPlayersAccountIdRefreshWithResponse request returning *PostPlayersAccountIdRefreshResponse
func (c *ClientWithResponses) PostPlayersAccountIdRefreshWithResponse(ctx context.Context, accountId AccountIdParam, reqEditors ...RequestEditorFn) (*PostPlayersAccountIdRefreshResponse, error) {
	rsp, err := c.PostPlayersAccountIdRefresh(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPlayersAccountIdRefreshResponse(rsp)
}

// GetPlayersByAccountIdSelectTotalsWithResponse request returning *GetPlayersByAccountIdSelectTotalsResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectTotalsWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectTotalsParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectTotalsResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectTotals(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectTotalsResponse(rsp)
}

// GetPlayersByAccountIdSelectWardmapWithResponse request returning *GetPlayersByAccountIdSelectWardmapResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectWardmapWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWardmapParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectWardmapResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectWardmap(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectWardmapResponse(rsp)
}

// GetPlayersByAccountIdSelectWlWithResponse request returning *GetPlayersByAccountIdSelectWlResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectWlWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWlParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectWlResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectWl(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectWlResponse(rsp)
}

// GetPlayersByAccountIdSelectWordcloudWithResponse request returning *GetPlayersByAccountIdSelectWordcloudResponse
func (c *ClientWithResponses) GetPlayersByAccountIdSelectWordcloudWithResponse(ctx context.Context, accountId AccountIdParam, params *GetPlayersByAccountIdSelectWordcloudParams, reqEditors ...RequestEditorFn) (*GetPlayersByAccountIdSelectWordcloudResponse, error) {
	rsp, err := c.GetPlayersByAccountIdSelectWordcloud(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByAccountIdSelectWordcloudResponse(rsp)
}

// GetPlayersByRankWithResponse request returning *GetPlayersByRankResponse
func (c *ClientWithResponses) GetPlayersByRankWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPlayersByRankResponse, error) {
	rsp, err := c.GetPlayersByRank(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlayersByRankResponse(rsp)
}

// GetProMatchesWithResponse request returning *GetProMatchesResponse
func (c *ClientWithResponses) GetProMatchesWithResponse(ctx context.Context, params *GetProMatchesParams, reqEditors ...RequestEditorFn) (*GetProMatchesResponse, error) {
	rsp, err := c.GetProMatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProMatchesResponse(rsp)
}

// GetProPlayersWithResponse request returning *GetProPlayersResponse
func (c *ClientWithResponses) GetProPlayersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProPlayersResponse, error) {
	rsp, err := c.GetProPlayers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProPlayersResponse(rsp)
}

// GetPublicMatchesWithResponse request returning *GetPublicMatchesResponse
func (c *ClientWithResponses) GetPublicMatchesWithResponse(ctx context.Context, params *GetPublicMatchesParams, reqEditors ...RequestEditorFn) (*GetPublicMatchesResponse, error) {
	rsp, err := c.GetPublicMatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicMatchesResponse(rsp)
}

// GetRankingsWithResponse request returning *GetRankingsResponse
func (c *ClientWithResponses) GetRankingsWithResponse(ctx context.Context, params *GetRankingsParams, reqEditors ...RequestEditorFn) (*GetRankingsResponse, error) {
	rsp, err := c.GetRankings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRankingsResponse(rsp)
}

// GetRecordsByFieldWithResponse request returning *GetRecordsByFieldResponse
func (c *ClientWithResponses) GetRecordsByFieldWithResponse(ctx context.Context, field string, reqEditors ...RequestEditorFn) (*GetRecordsByFieldResponse, error) {
	rsp, err := c.GetRecordsByField(ctx, field, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordsByFieldResponse(rsp)
}

// GetReplaysWithResponse request returning *GetReplaysResponse
func (c *ClientWithResponses) GetReplaysWithResponse(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*GetReplaysResponse, error) {
	rsp, err := c.GetReplays(ctx, matchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplaysResponse(rsp)
}

// GetRequestByJobIdWithResponse request returning *GetRequestByJobIdResponse
func (c *ClientWithResponses) GetRequestByJobIdWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetRequestByJobIdResponse, error) {
	rsp, err := c.GetRequestByJobId(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestByJobIdResponse(rsp)
}

// PostRequestMatchIdWithResponse request returning *PostRequestMatchIdResponse
func (c *ClientWithResponses) PostRequestMatchIdWithResponse(ctx context.Context, matchId MatchIdParam, reqEditors ...RequestEditorFn) (*PostRequestMatchIdResponse, error) {
	rsp, err := c.PostRequestMatchId(ctx, matchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRequestMatchIdResponse(rsp)
}

// GetScenariosItemTimingsWithResponse request returning *GetScenariosItemTimingsResponse
func (c *ClientWithResponses) GetScenariosItemTimingsWithResponse(ctx context.Context, params *GetScenariosItemTimingsParams, reqEditors ...RequestEditorFn) (*GetScenariosItemTimingsResponse, error) {
	rsp, err := c.GetScenariosItemTimings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScenariosItemTimingsResponse(rsp)
}

// GetScenariosLaneRolesWithResponse request returning *GetScenariosLaneRolesResponse
func (c *ClientWithResponses) GetScenariosLaneRolesWithResponse(ctx context.Context, params *GetScenariosLaneRolesParams, reqEditors ...RequestEditorFn) (*GetScenariosLaneRolesResponse, error) {
	rsp, err := c.GetScenariosLaneRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScenariosLaneRolesResponse(rsp)
}

// GetScenariosMiscWithResponse request returning *GetScenariosMiscResponse
func (c *ClientWithResponses) GetScenariosMiscWithResponse(ctx context.Context, params *GetScenariosMiscParams, reqEditors ...RequestEditorFn) (*GetScenariosMiscResponse, error) {
	rsp, err := c.GetScenariosMisc(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScenariosMiscResponse(rsp)
}

// GetSchemaWithResponse request returning *GetSchemaResponse
func (c *ClientWithResponses) GetSchemaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSchemaResponse, error) {
	rsp, err := c.GetSchema(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaResponse(rsp)
}

// GetSearchWithResponse request returning *GetSearchResponse
func (c *ClientWithResponses) GetSearchWithResponse(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*GetSearchResponse, error) {
	rsp, err := c.GetSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error) {
	rsp, err := c.GetTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsResponse(rsp)
}

// GetTeamsByTeamIdWithResponse request returning *GetTeamsByTeamIdResponse
func (c *ClientWithResponses) GetTeamsByTeamIdWithResponse(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*GetTeamsByTeamIdResponse, error) {
	rsp, err := c.GetTeamsByTeamId(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsByTeamIdResponse(rsp)
}

// GetTeamsByTeamIdSelectHeroesWithResponse request returning *GetTeamsByTeamIdSelectHeroesResponse
func (c *ClientWithResponses) GetTeamsByTeamIdSelectHeroesWithResponse(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*GetTeamsByTeamIdSelectHeroesResponse, error) {
	rsp, err := c.GetTeamsByTeamIdSelectHeroes(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsByTeamIdSelectHeroesResponse(rsp)
}

// GetTeamsByTeamIdSelectMatchesWithResponse request returning *GetTeamsByTeamIdSelectMatchesResponse
func (c *ClientWithResponses) GetTeamsByTeamIdSelectMatchesWithResponse(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*GetTeamsByTeamIdSelectMatchesResponse, error) {
	rsp, err := c.GetTeamsByTeamIdSelectMatches(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsByTeamIdSelectMatchesResponse(rsp)
}

// GetTeamsByTeamIdSelectPlayersWithResponse request returning *GetTeamsByTeamIdSelectPlayersResponse
func (c *ClientWithResponses) GetTeamsByTeamIdSelectPlayersWithResponse(ctx context.Context, teamId TeamIdPathParam, reqEditors ...RequestEditorFn) (*GetTeamsByTeamIdSelectPlayersResponse, error) {
	rsp, err := c.GetTeamsByTeamIdSelectPlayers(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsByTeamIdSelectPlayersResponse(rsp)
}

// ParseGetBenchmarksResponse parses an HTTP response from a GetBenchmarksWithResponse call
func ParseGetBenchmarksResponse(rsp *http.Response) (*GetBenchmarksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenchmarksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConstantsResponse parses an HTTP response from a GetConstantsWithResponse call
func ParseGetConstantsResponse(rsp *http.Response) (*GetConstantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConstantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConstantsByResourceResponse parses an HTTP response from a GetConstantsByResourceWithResponse call
func ParseGetConstantsByResourceResponse(rsp *http.Response) (*GetConstantsByResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConstantsByResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDistributionsResponse parses an HTTP response from a GetDistributionsWithResponse call
func ParseGetDistributionsResponse(rsp *http.Response) (*GetDistributionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDistributionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExplorerResponse parses an HTTP response from a GetExplorerWithResponse call
func ParseGetExplorerResponse(rsp *http.Response) (*GetExplorerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExplorerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFindMatchesResponse parses an HTTP response from a GetFindMatchesWithResponse call
func ParseGetFindMatchesResponse(rsp *http.Response) (*GetFindMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFindMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHeroStatsResponse parses an HTTP response from a GetHeroStatsWithResponse call
func ParseGetHeroStatsResponse(rsp *http.Response) (*GetHeroStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHeroStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHeroesResponse parses an HTTP response from a GetHeroesWithResponse call
func ParseGetHeroesResponse(rsp *http.Response) (*GetHeroesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHeroesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHeroesByHeroIdSelectDurationsResponse parses an HTTP response from a GetHeroesByHeroIdSelectDurationsWithResponse call
func ParseGetHeroesByHeroIdSelectDurationsResponse(rsp *http.Response) (*GetHeroesByHeroIdSelectDurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHeroesByHeroIdSelectDurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHeroesByHeroIdSelectItemPopularityResponse parses an HTTP response from a GetHeroesByHeroIdSelectItemPopularityWithResponse call
func ParseGetHeroesByHeroIdSelectItemPopularityResponse(rsp *http.Response) (*GetHeroesByHeroIdSelectItemPopularityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHeroesByHeroIdSelectItemPopularityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHeroesByHeroIdSelectMatchesResponse parses an HTTP response from a GetHeroesByHeroIdSelectMatchesWithResponse call
func ParseGetHeroesByHeroIdSelectMatchesResponse(rsp *http.Response) (*GetHeroesByHeroIdSelectMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHeroesByHeroIdSelectMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHeroesByHeroIdSelectMatchupsResponse parses an HTTP response from a GetHeroesByHeroIdSelectMatchupsWithResponse call
func ParseGetHeroesByHeroIdSelectMatchupsResponse(rsp *http.Response) (*GetHeroesByHeroIdSelectMatchupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHeroesByHeroIdSelectMatchupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHeroesByHeroIdSelectPlayersResponse parses an HTTP response from a GetHeroesByHeroIdSelectPlayersWithResponse call
func ParseGetHeroesByHeroIdSelectPlayersResponse(rsp *http.Response) (*GetHeroesByHeroIdSelectPlayersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHeroesByHeroIdSelectPlayersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLeaguesResponse parses an HTTP response from a GetLeaguesWithResponse call
func ParseGetLeaguesResponse(rsp *http.Response) (*GetLeaguesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaguesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLeaguesByLeagueIdResponse parses an HTTP response from a GetLeaguesByLeagueIdWithResponse call
func ParseGetLeaguesByLeagueIdResponse(rsp *http.Response) (*GetLeaguesByLeagueIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaguesByLeagueIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLeaguesByLeagueIdSelectMatchesResponse parses an HTTP response from a GetLeaguesByLeagueIdSelectMatchesWithResponse call
func ParseGetLeaguesByLeagueIdSelectMatchesResponse(rsp *http.Response) (*GetLeaguesByLeagueIdSelectMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaguesByLeagueIdSelectMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLeaguesByLeagueIdSelectTeamsResponse parses an HTTP response from a GetLeaguesByLeagueIdSelectTeamsWithResponse call
func ParseGetLeaguesByLeagueIdSelectTeamsResponse(rsp *http.Response) (*GetLeaguesByLeagueIdSelectTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaguesByLeagueIdSelectTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLiveResponse parses an HTTP response from a GetLiveWithResponse call
func ParseGetLiveResponse(rsp *http.Response) (*GetLiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMatchesByMatchIdResponse parses an HTTP response from a GetMatchesByMatchIdWithResponse call
func ParseGetMatchesByMatchIdResponse(rsp *http.Response) (*GetMatchesByMatchIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMatchesByMatchIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMetadataResponse parses an HTTP response from a GetMetadataWithResponse call
func ParseGetMetadataResponse(rsp *http.Response) (*GetMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetParsedMatchesResponse parses an HTTP response from a GetParsedMatchesWithResponse call
func ParseGetParsedMatchesResponse(rsp *http.Response) (*GetParsedMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParsedMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdResponse parses an HTTP response from a GetPlayersByAccountIdWithResponse call
func ParseGetPlayersByAccountIdResponse(rsp *http.Response) (*GetPlayersByAccountIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectCountsResponse parses an HTTP response from a GetPlayersByAccountIdSelectCountsWithResponse call
func ParseGetPlayersByAccountIdSelectCountsResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectCountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectCountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectHeroesResponse parses an HTTP response from a GetPlayersByAccountIdSelectHeroesWithResponse call
func ParseGetPlayersByAccountIdSelectHeroesResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectHeroesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectHeroesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdHistogramsByFieldResponse parses an HTTP response from a GetPlayersByAccountIdHistogramsByFieldWithResponse call
func ParseGetPlayersByAccountIdHistogramsByFieldResponse(rsp *http.Response) (*GetPlayersByAccountIdHistogramsByFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdHistogramsByFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectMatchesResponse parses an HTTP response from a GetPlayersByAccountIdSelectMatchesWithResponse call
func ParseGetPlayersByAccountIdSelectMatchesResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectPeersResponse parses an HTTP response from a GetPlayersByAccountIdSelectPeersWithResponse call
func ParseGetPlayersByAccountIdSelectPeersResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectPeersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectPeersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectProsResponse parses an HTTP response from a GetPlayersByAccountIdSelectProsWithResponse call
func ParseGetPlayersByAccountIdSelectProsResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectProsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectProsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectRankingsResponse parses an HTTP response from a GetPlayersByAccountIdSelectRankingsWithResponse call
func ParseGetPlayersByAccountIdSelectRankingsResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectRankingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectRankingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectRatingsResponse parses an HTTP response from a GetPlayersByAccountIdSelectRatingsWithResponse call
func ParseGetPlayersByAccountIdSelectRatingsResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectRatingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectRatingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectRecentMatchesResponse parses an HTTP response from a GetPlayersByAccountIdSelectRecentMatchesWithResponse call
func ParseGetPlayersByAccountIdSelectRecentMatchesResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectRecentMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectRecentMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostPlayersAccountIdRefreshResponse parses an HTTP response from a PostPlayersAccountIdRefreshWithResponse call
func ParsePostPlayersAccountIdRefreshResponse(rsp *http.Response) (*PostPlayersAccountIdRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPlayersAccountIdRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectTotalsResponse parses an HTTP response from a GetPlayersByAccountIdSelectTotalsWithResponse call
func ParseGetPlayersByAccountIdSelectTotalsResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectTotalsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectTotalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectWardmapResponse parses an HTTP response from a GetPlayersByAccountIdSelectWardmapWithResponse call
func ParseGetPlayersByAccountIdSelectWardmapResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectWardmapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectWardmapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectWlResponse parses an HTTP response from a GetPlayersByAccountIdSelectWlWithResponse call
func ParseGetPlayersByAccountIdSelectWlResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectWlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectWlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByAccountIdSelectWordcloudResponse parses an HTTP response from a GetPlayersByAccountIdSelectWordcloudWithResponse call
func ParseGetPlayersByAccountIdSelectWordcloudResponse(rsp *http.Response) (*GetPlayersByAccountIdSelectWordcloudResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByAccountIdSelectWordcloudResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlayersByRankResponse parses an HTTP response from a GetPlayersByRankWithResponse call
func ParseGetPlayersByRankResponse(rsp *http.Response) (*GetPlayersByRankResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlayersByRankResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProMatchesResponse parses an HTTP response from a GetProMatchesWithResponse call
func ParseGetProMatchesResponse(rsp *http.Response) (*GetProMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProPlayersResponse parses an HTTP response from a GetProPlayersWithResponse call
func ParseGetProPlayersResponse(rsp *http.Response) (*GetProPlayersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProPlayersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPublicMatchesResponse parses an HTTP response from a GetPublicMatchesWithResponse call
func ParseGetPublicMatchesResponse(rsp *http.Response) (*GetPublicMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRankingsResponse parses an HTTP response from a GetRankingsWithResponse call
func ParseGetRankingsResponse(rsp *http.Response) (*GetRankingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRankingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRecordsByFieldResponse parses an HTTP response from a GetRecordsByFieldWithResponse call
func ParseGetRecordsByFieldResponse(rsp *http.Response) (*GetRecordsByFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordsByFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReplaysResponse parses an HTTP response from a GetReplaysWithResponse call
func ParseGetReplaysResponse(rsp *http.Response) (*GetReplaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRequestByJobIdResponse parses an HTTP response from a GetRequestByJobIdWithResponse call
func ParseGetRequestByJobIdResponse(rsp *http.Response) (*GetRequestByJobIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestByJobIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostRequestMatchIdResponse parses an HTTP response from a PostRequestMatchIdWithResponse call
func ParsePostRequestMatchIdResponse(rsp *http.Response) (*PostRequestMatchIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRequestMatchIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetScenariosItemTimingsResponse parses an HTTP response from a GetScenariosItemTimingsWithResponse call
func ParseGetScenariosItemTimingsResponse(rsp *http.Response) (*GetScenariosItemTimingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScenariosItemTimingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetScenariosLaneRolesResponse parses an HTTP response from a GetScenariosLaneRolesWithResponse call
func ParseGetScenariosLaneRolesResponse(rsp *http.Response) (*GetScenariosLaneRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScenariosLaneRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetScenariosMiscResponse parses an HTTP response from a GetScenariosMiscWithResponse call
func ParseGetScenariosMiscResponse(rsp *http.Response) (*GetScenariosMiscResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScenariosMiscResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaResponse parses an HTTP response from a GetSchemaWithResponse call
func ParseGetSchemaResponse(rsp *http.Response) (*GetSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSearchResponse parses an HTTP response from a GetSearchWithResponse call
func ParseGetSearchResponse(rsp *http.Response) (*GetSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTeamsByTeamIdResponse parses an HTTP response from a GetTeamsByTeamIdWithResponse call
func ParseGetTeamsByTeamIdResponse(rsp *http.Response) (*GetTeamsByTeamIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsByTeamIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTeamsByTeamIdSelectHeroesResponse parses an HTTP response from a GetTeamsByTeamIdSelectHeroesWithResponse call
func ParseGetTeamsByTeamIdSelectHeroesResponse(rsp *http.Response) (*GetTeamsByTeamIdSelectHeroesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsByTeamIdSelectHeroesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTeamsByTeamIdSelectMatchesResponse parses an HTTP response from a GetTeamsByTeamIdSelectMatchesWithResponse call
func ParseGetTeamsByTeamIdSelectMatchesResponse(rsp *http.Response) (*GetTeamsByTeamIdSelectMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsByTeamIdSelectMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTeamsByTeamIdSelectPlayersResponse parses an HTTP response from a GetTeamsByTeamIdSelectPlayersWithResponse call
func ParseGetTeamsByTeamIdSelectPlayersResponse(rsp *http.Response) (*GetTeamsByTeamIdSelectPlayersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsByTeamIdSelectPlayersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
